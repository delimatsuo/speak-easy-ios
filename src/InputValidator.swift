//
//  InputValidator.swift
//  UniversalTranslator
//
//  Comprehensive input validation service with security measures,
//  attack pattern detection, and sanitization capabilities.
//

import Foundation

// MARK: - Validation Errors

enum ValidationError: Error, LocalizedError {
    case emptyInput
    case tooLong(Int)
    case tooShort(Int)
    case invalidCharacters
    case potentialXSSAttack
    case potentialSQLInjection
    case potentialCommandInjection
    case maliciousPattern
    case invalidFormat
    case invalidLanguageCode
    case invalidAudioFormat
    case fileTooLarge(Int)
    case suspiciousActivity
    
    var errorDescription: String? {
        switch self {
        case .emptyInput:
            return "Input cannot be empty"
        case .tooLong(let max):
            return "Input exceeds maximum length of \(max) characters"
        case .tooShort(let min):
            return "Input must be at least \(min) characters"
        case .invalidCharacters:
            return "Input contains invalid characters"
        case .potentialXSSAttack:
            return "Input contains potential XSS attack patterns"
        case .potentialSQLInjection:
            return "Input contains potential SQL injection patterns"
        case .potentialCommandInjection:
            return "Input contains potential command injection patterns"
        case .maliciousPattern:
            return "Input contains malicious patterns"
        case .invalidFormat:
            return "Input format is invalid"
        case .invalidLanguageCode:
            return "Invalid language code"
        case .invalidAudioFormat:
            return "Invalid audio format"
        case .fileTooLarge(let max):
            return "File exceeds maximum size of \(max) bytes"
        case .suspiciousActivity:
            return "Suspicious activity detected"
        }\n    }\n}\n\n// MARK: - Validation Rules\n\nstruct ValidationRule {\n    let name: String\n    let pattern: String\n    let isBlacklist: Bool // true for forbidden patterns, false for required patterns\n    let severity: SecuritySeverity\n    \n    enum SecuritySeverity {\n        case low\n        case medium\n        case high\n        case critical\n    }\n}\n\n// MARK: - Input Validator\n\nclass InputValidator {\n    static let shared = InputValidator()\n    \n    // MARK: - Configuration\n    \n    private let maxTextLength = 10000\n    private let minTextLength = 1\n    private let maxAudioFileSize = 50 * 1024 * 1024 // 50MB\n    private let supportedLanguageCodes = Set([\n        \"en\", \"es\", \"fr\", \"de\", \"it\", \"pt\", \"ja\", \"ko\", \"zh\", \"ar\",\n        \"ru\", \"hi\", \"th\", \"vi\", \"tr\", \"pl\", \"nl\", \"sv\", \"da\", \"no\"\n    ])\n    \n    // MARK: - Security Patterns\n    \n    private let securityPatterns: [ValidationRule] = [\n        // XSS Attack Patterns\n        ValidationRule(\n            name: \"Script Tag\",\n            pattern: \"<script[^>]*>.*?</script>\",\n            isBlacklist: true,\n            severity: .critical\n        ),\n        ValidationRule(\n            name: \"JavaScript Event Handler\",\n            pattern: \"on(click|load|error|focus|blur|change|submit|mouseover)\\\\s*=\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        ValidationRule(\n            name: \"JavaScript Protocol\",\n            pattern: \"javascript:\\\\s*\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        ValidationRule(\n            name: \"Data URI with Script\",\n            pattern: \"data:.*script\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        \n        // SQL Injection Patterns\n        ValidationRule(\n            name: \"SQL Keywords\",\n            pattern: \"\\\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|UNION|OR|AND)\\\\b\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        ValidationRule(\n            name: \"SQL Comment\",\n            pattern: \"(--)|(;)|(\\\\*)\",\n            isBlacklist: true,\n            severity: .medium\n        ),\n        ValidationRule(\n            name: \"SQL Quote Escape\",\n            pattern: \"('(''|[^'])*')|(\\\"(\\\\\\\"|[^\\\"])*\\\")\",\n            isBlacklist: true,\n            severity: .medium\n        ),\n        \n        // Command Injection Patterns\n        ValidationRule(\n            name: \"Shell Commands\",\n            pattern: \"\\\\b(cat|ls|rm|cp|mv|chmod|chown|ps|kill|wget|curl|nc|telnet)\\\\b\",\n            isBlacklist: true,\n            severity: .critical\n        ),\n        ValidationRule(\n            name: \"Command Separators\",\n            pattern: \"[;&|`$(){}\\\\[\\\\]]\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        \n        // Path Traversal\n        ValidationRule(\n            name: \"Path Traversal\",\n            pattern: \"\\\\.\\\\./|\\\\.\\\\.\\\\\\\\\",\n            isBlacklist: true,\n            severity: .high\n        ),\n        \n        // Malicious URLs\n        ValidationRule(\n            name: \"Suspicious URLs\",\n            pattern: \"(file://|ftp://|data:)|(localhost|127\\\\.0\\\\.0\\\\.1|0\\\\.0\\\\.0\\\\.0)\",\n            isBlacklist: true,\n            severity: .medium\n        ),\n        \n        // Unicode attacks\n        ValidationRule(\n            name: \"Control Characters\",\n            pattern: \"[\\\\x00-\\\\x1F\\\\x7F-\\\\x9F]\",\n            isBlacklist: true,\n            severity: .medium\n        )\n    ]\n    \n    private init() {}\n    \n    // MARK: - Text Validation\n    \n    /// Validate translation text input\n    func validateTranslationText(_ text: String) throws {\n        // Basic validation\n        try validateBasicText(text)\n        \n        // Security validation\n        try validateSecurity(text)\n        \n        // Content validation\n        try validateContent(text)\n    }\n    \n    /// Validate basic text requirements\n    private func validateBasicText(_ text: String) throws {\n        // Check if empty\n        if text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {\n            throw ValidationError.emptyInput\n        }\n        \n        // Check length\n        if text.count > maxTextLength {\n            throw ValidationError.tooLong(maxTextLength)\n        }\n        \n        if text.count < minTextLength {\n            throw ValidationError.tooShort(minTextLength)\n        }\n    }\n    \n    /// Validate against security threats\n    private func validateSecurity(_ text: String) throws {\n        let lowercaseText = text.lowercased()\n        \n        for rule in securityPatterns {\n            let regex = try NSRegularExpression(pattern: rule.pattern, options: [.caseInsensitive, .dotMatchesLineSeparators])\n            let range = NSRange(location: 0, length: text.count)\n            let matches = regex.numberOfMatches(in: text, options: [], range: range)\n            \n            if rule.isBlacklist && matches > 0 {\n                switch rule.severity {\n                case .critical:\n                    throw ValidationError.potentialCommandInjection\n                case .high:\n                    if rule.name.contains(\"XSS\") || rule.name.contains(\"Script\") || rule.name.contains(\"JavaScript\") {\n                        throw ValidationError.potentialXSSAttack\n                    } else if rule.name.contains(\"SQL\") {\n                        throw ValidationError.potentialSQLInjection\n                    } else {\n                        throw ValidationError.potentialCommandInjection\n                    }\n                case .medium, .low:\n                    throw ValidationError.maliciousPattern\n                }\n            }\n        }\n    }\n    \n    /// Validate content appropriateness\n    private func validateContent(_ text: String) throws {\n        // Check for excessive repetition (potential DoS)\n        if hasExcessiveRepetition(text) {\n            throw ValidationError.suspiciousActivity\n        }\n        \n        // Check for valid Unicode\n        if !text.canBeConverted(to: .utf8) {\n            throw ValidationError.invalidCharacters\n        }\n    }\n    \n    // MARK: - Language Code Validation\n    \n    /// Validate language code\n    func validateLanguageCode(_ code: String) throws {\n        let normalizedCode = code.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)\n        \n        if normalizedCode.isEmpty {\n            throw ValidationError.emptyInput\n        }\n        \n        if !supportedLanguageCodes.contains(normalizedCode) {\n            throw ValidationError.invalidLanguageCode\n        }\n    }\n    \n    // MARK: - Audio Validation\n    \n    /// Validate audio data\n    func validateAudioData(_ data: Data) throws {\n        if data.isEmpty {\n            throw ValidationError.emptyInput\n        }\n        \n        if data.count > maxAudioFileSize {\n            throw ValidationError.fileTooLarge(maxAudioFileSize)\n        }\n        \n        // Check for valid audio format headers\n        if !isValidAudioFormat(data) {\n            throw ValidationError.invalidAudioFormat\n        }\n    }\n    \n    /// Validate audio file URL\n    func validateAudioFileURL(_ url: URL) throws {\n        // Check if file exists\n        guard FileManager.default.fileExists(atPath: url.path) else {\n            throw ValidationError.invalidFormat\n        }\n        \n        // Check file size\n        let fileSize = try FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int ?? 0\n        if fileSize > maxAudioFileSize {\n            throw ValidationError.fileTooLarge(maxAudioFileSize)\n        }\n        \n        // Read and validate header\n        let headerData = try Data(contentsOf: url, options: [.mappedIfSafe]).prefix(16)\n        if !isValidAudioFormat(headerData) {\n            throw ValidationError.invalidAudioFormat\n        }\n    }\n    \n    // MARK: - Sanitization\n    \n    /// Sanitize text input for safe processing\n    func sanitizeText(_ text: String) -> String {\n        var sanitized = text\n        \n        // Remove control characters\n        sanitized = sanitized.components(separatedBy: CharacterSet.controlCharacters).joined()\n        \n        // Normalize Unicode\n        sanitized = sanitized.precomposedStringWithCanonicalMapping\n        \n        // Trim whitespace\n        sanitized = sanitized.trimmingCharacters(in: .whitespacesAndNewlines)\n        \n        // Limit length\n        if sanitized.count > maxTextLength {\n            sanitized = String(sanitized.prefix(maxTextLength))\n        }\n        \n        // HTML encode dangerous characters\n        sanitized = htmlEncode(sanitized)\n        \n        return sanitized\n    }\n    \n    /// HTML encode dangerous characters\n    private func htmlEncode(_ text: String) -> String {\n        return text\n            .replacingOccurrences(of: \"&\", with: \"&amp;\")\n            .replacingOccurrences(of: \"<\", with: \"&lt;\")\n            .replacingOccurrences(of: \">\", with: \"&gt;\")\n            .replacingOccurrences(of: \"\\\"\", with: \"&quot;\")\n            .replacingOccurrences(of: \"'\", with: \"&#x27;\")\n            .replacingOccurrences(of: \"/\", with: \"&#x2F;\")\n    }\n    \n    // MARK: - Helper Methods\n    \n    /// Check for excessive character repetition\n    private func hasExcessiveRepetition(_ text: String) -> Bool {\n        let maxRepetition = 10\n        var currentChar: Character?\n        var count = 0\n        \n        for char in text {\n            if char == currentChar {\n                count += 1\n                if count > maxRepetition {\n                    return true\n                }\n            } else {\n                currentChar = char\n                count = 1\n            }\n        }\n        \n        return false\n    }\n    \n    /// Check if data has valid audio format headers\n    private func isValidAudioFormat(_ data: Data) -> Bool {\n        guard data.count >= 4 else { return false }\n        \n        let header = data.prefix(4)\n        \n        // Check for common audio format signatures\n        let audioSignatures: [[UInt8]] = [\n            [0x66, 0x74, 0x79, 0x70], // ftyp (M4A/AAC)\n            [0x49, 0x44, 0x33],       // ID3 (MP3)\n            [0xFF, 0xFB],             // MP3 frame header\n            [0xFF, 0xF3],             // MP3 frame header\n            [0xFF, 0xF2],             // MP3 frame header\n            [0x52, 0x49, 0x46, 0x46], // RIFF (WAV)\n            [0x4F, 0x67, 0x67, 0x53], // OggS (OGG)\n            [0x66, 0x4C, 0x61, 0x43]  // fLaC (FLAC)\n        ]\n        \n        let headerBytes = Array(header)\n        \n        return audioSignatures.contains { signature in\n            if signature.count <= headerBytes.count {\n                return Array(headerBytes.prefix(signature.count)) == signature\n            }\n            return false\n        }\n    }\n    \n    // MARK: - Rate Limiting Support\n    \n    private var requestCounts: [String: (count: Int, timestamp: Date)] = [:]\n    private let maxRequestsPerMinute = 60\n    \n    /// Check if request should be rate limited\n    func shouldRateLimit(identifier: String) -> Bool {\n        let now = Date()\n        let minute = 60.0\n        \n        if let existing = requestCounts[identifier] {\n            if now.timeIntervalSince(existing.timestamp) < minute {\n                if existing.count >= maxRequestsPerMinute {\n                    return true\n                }\n                requestCounts[identifier] = (existing.count + 1, existing.timestamp)\n            } else {\n                requestCounts[identifier] = (1, now)\n            }\n        } else {\n            requestCounts[identifier] = (1, now)\n        }\n        \n        // Clean old entries\n        requestCounts = requestCounts.filter { now.timeIntervalSince($0.value.timestamp) < minute }\n        \n        return false\n    }\n}\n\n// MARK: - Validation Extensions\n\nextension String {\n    /// Check if string contains only safe characters\n    var isSafe: Bool {\n        let allowedCharacterSet = CharacterSet.alphanumerics\n            .union(.punctuationCharacters)\n            .union(.whitespaces)\n            .union(.symbols)\n        \n        return rangeOfCharacter(from: allowedCharacterSet.inverted) == nil\n    }\n    \n    /// Remove potentially dangerous characters\n    var sanitized: String {\n        return InputValidator.shared.sanitizeText(self)\n    }\n}\n"
  }
]