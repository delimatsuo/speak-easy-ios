//
//  SecurityMonitor.swift
//  UniversalTranslator
//
//  Comprehensive security monitoring service with anomaly detection,\n//  threat intelligence, real-time alerts, and automated responses.\n//\n\nimport Foundation\nimport Network\nimport Combine\n\n// MARK: - Security Threat Types\n\nenum SecurityThreat: String, CaseIterable {\n    case bruteForceAttack = \"brute_force\"\n    case ddosAttack = \"ddos\"\n    case sqlInjection = \"sql_injection\"\n    case xssAttack = \"xss_attack\"\n    case commandInjection = \"command_injection\"\n    case dataLeakage = \"data_leakage\"\n    case unauthorizedAccess = \"unauthorized_access\"\n    case suspiciousUserAgent = \"suspicious_user_agent\"\n    case anomalousTraffic = \"anomalous_traffic\"\n    case credentialStuffing = \"credential_stuffing\"\n    case apiAbuse = \"api_abuse\"\n    case maliciousPayload = \"malicious_payload\"\n}\n\n// MARK: - Security Event\n\nstruct SecurityEvent {\n    let id: UUID = UUID()\n    let timestamp: Date = Date()\n    let threat: SecurityThreat\n    let severity: SecuritySeverity\n    let source: String // IP, user ID, etc.\n    let details: [String: Any]\n    let blocked: Bool\n    let falsePositive: Bool = false\n    \n    enum SecuritySeverity: Int, CaseIterable {\n        case low = 1\n        case medium = 2\n        case high = 3\n        case critical = 4\n        \n        var description: String {\n            switch self {\n            case .low: return \"Low\"\n            case .medium: return \"Medium\"\n            case .high: return \"High\"\n            case .critical: return \"Critical\"\n            }\n        }\n    }\n}\n\n// MARK: - Security Metrics\n\nstruct SecurityMetrics {\n    let totalThreats: Int\n    let threatsBlocked: Int\n    let falsePositives: Int\n    let criticalThreats: Int\n    let topThreatTypes: [SecurityThreat: Int]\n    let topSources: [String: Int]\n    let averageResponseTime: TimeInterval\n    let systemHealth: SystemHealth\n    \n    enum SystemHealth {\n        case healthy\n        case warning\n        case critical\n        case underAttack\n    }\n}\n\n// MARK: - Anomaly Detection Config\n\nstruct AnomalyConfig {\n    let requestThreshold: Int\n    let timeWindow: TimeInterval\n    let failureRateThreshold: Double\n    let patternDetectionEnabled: Bool\n    let mlDetectionEnabled: Bool\n    let geoLocationChecks: Bool\n    \n    static let `default` = AnomalyConfig(\n        requestThreshold: 100,\n        timeWindow: 300, // 5 minutes\n        failureRateThreshold: 0.3, // 30%\n        patternDetectionEnabled: true,\n        mlDetectionEnabled: false, // Disabled for now\n        geoLocationChecks: false   // Requires external service\n    )\n}\n\n// MARK: - Security Monitor\n\nclass SecurityMonitor: ObservableObject {\n    static let shared = SecurityMonitor()\n    \n    // MARK: - Configuration\n    private var config: AnomalyConfig\n    private let queue = DispatchQueue(label: \"security-monitor\", attributes: .concurrent)\n    private var cancellables = Set<AnyCancellable>()\n    \n    // MARK: - Storage\n    private var events: [SecurityEvent] = []\n    private var blockedSources: Set<String> = []\n    private var requestHistory: [String: [Date]] = [:]\n    private var failureHistory: [String: [Date]] = [:]\n    private var userAgentHistory: [String: Int] = [:]\n    \n    // MARK: - Monitoring State\n    @Published private(set) var isMonitoringActive = true\n    @Published private(set) var currentMetrics = SecurityMetrics(\n        totalThreats: 0,\n        threatsBlocked: 0,\n        falsePositives: 0,\n        criticalThreats: 0,\n        topThreatTypes: [:],\n        topSources: [:],\n        averageResponseTime: 0,\n        systemHealth: .healthy\n    )\n    @Published private(set) var recentEvents: [SecurityEvent] = []\n    @Published private(set) var activeThreats: [SecurityThreat: Int] = [:]\n    \n    // MARK: - Threat Detection Patterns\n    private let suspiciousUserAgents = [\n        \"sqlmap\", \"nikto\", \"nmap\", \"masscan\", \"zap\", \"w3af\",\n        \"burp\", \"acunetix\", \"netsparker\", \"appscan\", \"crawler\"\n    ]\n    \n    private let maliciousPatterns = [\n        \"<script\", \"javascript:\", \"vbscript:\", \"onload=\", \"onerror=\",\n        \"union select\", \"drop table\", \"'; drop\", \"1=1--\",\n        \"../../../\", \"..\\\\..\\\\..\\\\\" , \"/etc/passwd\", \"cmd.exe\",\n        \"powershell\", \"bash -c\", \"wget \", \"curl \"\n    ]\n    \n    // Cleanup timer\n    private var cleanupTimer: Timer?\n    private var metricsTimer: Timer?\n    \n    // MARK: - Initialization\n    \n    private init(config: AnomalyConfig = .default) {\n        self.config = config\n        startMonitoring()\n    }\n    \n    deinit {\n        stopMonitoring()\n    }\n    \n    // MARK: - Public Interface\n    \n    /// Analyze a request for security threats\n    func analyzeRequest(_ request: URLRequest, source: String, payload: Data? = nil) -> [SecurityEvent] {\n        return queue.sync {\n            var detectedEvents: [SecurityEvent] = []\n            \n            // Check if source is already blocked\n            if blockedSources.contains(source) {\n                let event = SecurityEvent(\n                    threat: .unauthorizedAccess,\n                    severity: .high,\n                    source: source,\n                    details: [\"reason\": \"Blocked source attempted access\"],\n                    blocked: true\n                )\n                detectedEvents.append(event)\n                return detectedEvents\n            }\n            \n            // Analyze request components\n            detectedEvents.append(contentsOf: analyzeURL(request.url, source: source))\n            detectedEvents.append(contentsOf: analyzeHeaders(request.allHTTPHeaderFields, source: source))\n            \n            if let payload = payload {\n                detectedEvents.append(contentsOf: analyzePayload(payload, source: source))\n            }\n            \n            // Traffic pattern analysis\n            detectedEvents.append(contentsOf: analyzeTrafficPattern(source: source))\n            \n            // Process all detected events\n            for event in detectedEvents {\n                processSecurityEvent(event)\n            }\n            \n            return detectedEvents\n        }\n    }\n    \n    /// Record a failed request for pattern analysis\n    func recordFailure(source: String, reason: String) {\n        queue.async(flags: .barrier) {\n            if self.failureHistory[source] == nil {\n                self.failureHistory[source] = []\n            }\n            self.failureHistory[source]?.append(Date())\n            \n            // Check for brute force patterns\n            let recentFailures = self.countRecentEvents(self.failureHistory[source] ?? [], window: 300) // 5 minutes\n            \n            if recentFailures >= 10 {\n                let event = SecurityEvent(\n                    threat: .bruteForceAttack,\n                    severity: .high,\n                    source: source,\n                    details: [\"failures\": recentFailures, \"reason\": reason],\n                    blocked: true\n                )\n                self.processSecurityEvent(event)\n            }\n        }\n    }\n    \n    /// Check if a source should be blocked\n    func shouldBlockSource(_ source: String) -> Bool {\n        return queue.sync {\n            blockedSources.contains(source)\n        }\n    }\n    \n    /// Manually block a source\n    func blockSource(_ source: String, reason: String = \"Manual block\") {\n        queue.async(flags: .barrier) {\n            self.blockedSources.insert(source)\n            \n            let event = SecurityEvent(\n                threat: .unauthorizedAccess,\n                severity: .medium,\n                source: source,\n                details: [\"reason\": reason],\n                blocked: true\n            )\n            self.processSecurityEvent(event)\n        }\n    }\n    \n    /// Unblock a source\n    func unblockSource(_ source: String) {\n        queue.async(flags: .barrier) {\n            self.blockedSources.remove(source)\n        }\n    }\n    \n    /// Get security metrics for dashboard\n    func getSecurityMetrics() -> SecurityMetrics {\n        return queue.sync {\n            calculateMetrics()\n        }\n    }\n    \n    /// Get recent security events\n    func getRecentEvents(limit: Int = 100) -> [SecurityEvent] {\n        return queue.sync {\n            Array(events.suffix(limit))\n        }\n    }\n    \n    /// Export security events for analysis\n    func exportEvents(since date: Date) -> [SecurityEvent] {\n        return queue.sync {\n            events.filter { $0.timestamp >= date }\n        }\n    }\n    \n    /// Update monitoring configuration\n    func updateConfig(_ newConfig: AnomalyConfig) {\n        queue.async(flags: .barrier) {\n            self.config = newConfig\n        }\n    }\n    \n    // MARK: - Private Analysis Methods\n    \n    private func analyzeURL(_ url: URL?, source: String) -> [SecurityEvent] {\n        guard let url = url else { return [] }\n        \n        var events: [SecurityEvent] = []\n        let urlString = url.absoluteString.lowercased()\n        \n        // Check for path traversal\n        if urlString.contains(\"../\") || urlString.contains(\"..\\\\\\\\) {\n            events.append(SecurityEvent(\n                threat: .commandInjection,\n                severity: .high,\n                source: source,\n                details: [\"url\": url.absoluteString, \"pattern\": \"path_traversal\"],\n                blocked: true\n            ))\n        }\n        \n        // Check for SQL injection patterns in URL\n        for pattern in maliciousPatterns {\n            if urlString.contains(pattern.lowercased()) {\n                let threat: SecurityThreat\n                if pattern.contains(\"select\") || pattern.contains(\"drop\") {\n                    threat = .sqlInjection\n                } else if pattern.contains(\"script\") || pattern.contains(\"javascript\") {\n                    threat = .xssAttack\n                } else {\n                    threat = .maliciousPayload\n                }\n                \n                events.append(SecurityEvent(\n                    threat: threat,\n                    severity: .high,\n                    source: source,\n                    details: [\"url\": url.absoluteString, \"pattern\": pattern],\n                    blocked: true\n                ))\n            }\n        }\n        \n        return events\n    }\n    \n    private func analyzeHeaders(_ headers: [String: String]?, source: String) -> [SecurityEvent] {\n        guard let headers = headers else { return [] }\n        \n        var events: [SecurityEvent] = []\n        \n        // Analyze User-Agent\n        if let userAgent = headers[\"User-Agent\"]?.lowercased() {\n            for suspiciousAgent in suspiciousUserAgents {\n                if userAgent.contains(suspiciousAgent) {\n                    events.append(SecurityEvent(\n                        threat: .suspiciousUserAgent,\n                        severity: .medium,\n                        source: source,\n                        details: [\"user_agent\": userAgent, \"suspicious_pattern\": suspiciousAgent],\n                        blocked: true\n                    ))\n                    break\n                }\n            }\n            \n            // Track user agent frequency\n            userAgentHistory[userAgent] = (userAgentHistory[userAgent] ?? 0) + 1\n        }\n        \n        // Check for suspicious headers\n        let suspiciousHeaders = [\"X-Forwarded-For\", \"X-Real-IP\", \"X-Originating-IP\"]\n        for header in suspiciousHeaders {\n            if let value = headers[header] {\n                // Multiple comma-separated IPs might indicate proxy chaining\n                if value.components(separatedBy: \",\").count > 3 {\n                    events.append(SecurityEvent(\n                        threat: .suspiciousUserAgent,\n                        severity: .low,\n                        source: source,\n                        details: [\"header\": header, \"value\": value],\n                        blocked: false\n                    ))\n                }\n            }\n        }\n        \n        return events\n    }\n    \n    private func analyzePayload(_ payload: Data, source: String) -> [SecurityEvent] {\n        guard let payloadString = String(data: payload, encoding: .utf8) else {\n            return []\n        }\n        \n        var events: [SecurityEvent] = []\n        let lowercasePayload = payloadString.lowercased()\n        \n        // Check for malicious patterns in payload\n        for pattern in maliciousPatterns {\n            if lowercasePayload.contains(pattern.lowercased()) {\n                let threat: SecurityThreat\n                let severity: SecurityEvent.SecuritySeverity\n                \n                if pattern.contains(\"script\") || pattern.contains(\"javascript\") {\n                    threat = .xssAttack\n                    severity = .high\n                } else if pattern.contains(\"select\") || pattern.contains(\"drop\") {\n                    threat = .sqlInjection\n                    severity = .critical\n                } else if pattern.contains(\"cmd\") || pattern.contains(\"bash\") {\n                    threat = .commandInjection\n                    severity = .critical\n                } else {\n                    threat = .maliciousPayload\n                    severity = .medium\n                }\n                \n                events.append(SecurityEvent(\n                    threat: threat,\n                    severity: severity,\n                    source: source,\n                    details: [\"payload_size\": payload.count, \"pattern\": pattern],\n                    blocked: true\n                ))\n            }\n        }\n        \n        // Check payload size for potential DoS\n        if payload.count > 1024 * 1024 { // 1MB\n            events.append(SecurityEvent(\n                threat: .ddosAttack,\n                severity: .medium,\n                source: source,\n                details: [\"payload_size\": payload.count],\n                blocked: false\n            ))\n        }\n        \n        return events\n    }\n    \n    private func analyzeTrafficPattern(source: String) -> [SecurityEvent] {\n        var events: [SecurityEvent] = []\n        \n        // Record request\n        if requestHistory[source] == nil {\n            requestHistory[source] = []\n        }\n        requestHistory[source]?.append(Date())\n        \n        // Check for DDoS patterns\n        let recentRequests = countRecentEvents(requestHistory[source] ?? [], window: config.timeWindow)\n        \n        if recentRequests > config.requestThreshold {\n            events.append(SecurityEvent(\n                threat: .ddosAttack,\n                severity: recentRequests > config.requestThreshold * 2 ? .critical : .high,\n                source: source,\n                details: [\"requests_in_window\": recentRequests, \"time_window\": config.timeWindow],\n                blocked: true\n            ))\n        }\n        \n        // Check failure rate\n        let recentFailures = countRecentEvents(failureHistory[source] ?? [], window: config.timeWindow)\n        let failureRate = recentRequests > 0 ? Double(recentFailures) / Double(recentRequests) : 0\n        \n        if failureRate > config.failureRateThreshold && recentRequests > 10 {\n            events.append(SecurityEvent(\n                threat: .credentialStuffing,\n                severity: .medium,\n                source: source,\n                details: [\"failure_rate\": failureRate, \"threshold\": config.failureRateThreshold],\n                blocked: false\n            ))\n        }\n        \n        return events\n    }\n    \n    private func processSecurityEvent(_ event: SecurityEvent) {\n        events.append(event)\n        \n        // Auto-block for critical threats\n        if event.severity == .critical || event.blocked {\n            blockedSources.insert(event.source)\n        }\n        \n        // Update real-time data\n        DispatchQueue.main.async {\n            self.recentEvents.insert(event, at: 0)\n            if self.recentEvents.count > 50 {\n                self.recentEvents = Array(self.recentEvents.prefix(50))\n            }\n            \n            self.activeThreats[event.threat] = (self.activeThreats[event.threat] ?? 0) + 1\n        }\n        \n        // Log critical events\n        if event.severity.rawValue >= SecurityEvent.SecuritySeverity.high.rawValue {\n            print(\"🚨 SECURITY ALERT: \\(event.threat.rawValue) from \\(event.source) - \\(event.severity.description)\")\n        }\n    }\n    \n    private func countRecentEvents(_ timestamps: [Date], window: TimeInterval) -> Int {\n        let cutoff = Date().addingTimeInterval(-window)\n        return timestamps.filter { $0 >= cutoff }.count\n    }\n    \n    private func calculateMetrics() -> SecurityMetrics {\n        let now = Date()\n        let dayAgo = now.addingTimeInterval(-86400)\n        \n        let recentEvents = events.filter { $0.timestamp >= dayAgo }\n        \n        let totalThreats = recentEvents.count\n        let threatsBlocked = recentEvents.filter { $0.blocked }.count\n        let falsePositives = recentEvents.filter { $0.falsePositive }.count\n        let criticalThreats = recentEvents.filter { $0.severity == .critical }.count\n        \n        var topThreatTypes: [SecurityThreat: Int] = [:]\n        var topSources: [String: Int] = [:]\n        \n        for event in recentEvents {\n            topThreatTypes[event.threat] = (topThreatTypes[event.threat] ?? 0) + 1\n            topSources[event.source] = (topSources[event.source] ?? 0) + 1\n        }\n        \n        let systemHealth: SecurityMetrics.SystemHealth\n        if criticalThreats > 10 {\n            systemHealth = .underAttack\n        } else if criticalThreats > 5 || threatsBlocked > 50 {\n            systemHealth = .critical\n        } else if totalThreats > 20 {\n            systemHealth = .warning\n        } else {\n            systemHealth = .healthy\n        }\n        \n        return SecurityMetrics(\n            totalThreats: totalThreats,\n            threatsBlocked: threatsBlocked,\n            falsePositives: falsePositives,\n            criticalThreats: criticalThreats,\n            topThreatTypes: topThreatTypes,\n            topSources: topSources,\n            averageResponseTime: 0.05, // Placeholder\n            systemHealth: systemHealth\n        )\n    }\n    \n    // MARK: - Monitoring Lifecycle\n    \n    private func startMonitoring() {\n        isMonitoringActive = true\n        \n        // Start cleanup timer\n        cleanupTimer = Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { [weak self] _ in\n            self?.performCleanup()\n        }\n        \n        // Start metrics update timer\n        metricsTimer = Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { [weak self] _ in\n            self?.updateMetrics()\n        }\n        \n        print(\"🛡️ Security monitoring started\")\n    }\n    \n    private func stopMonitoring() {\n        isMonitoringActive = false\n        cleanupTimer?.invalidate()\n        metricsTimer?.invalidate()\n        print(\"🛡️ Security monitoring stopped\")\n    }\n    \n    private func performCleanup() {\n        queue.async(flags: .barrier) {\n            let now = Date()\n            let dayAgo = now.addingTimeInterval(-86400)\n            \n            // Clean old events\n            self.events = self.events.filter { $0.timestamp > dayAgo }\n            \n            // Clean old request history\n            for source in self.requestHistory.keys {\n                self.requestHistory[source] = self.requestHistory[source]?.filter { $0 > dayAgo }\n                if self.requestHistory[source]?.isEmpty == true {\n                    self.requestHistory.removeValue(forKey: source)\n                }\n            }\n            \n            // Clean old failure history\n            for source in self.failureHistory.keys {\n                self.failureHistory[source] = self.failureHistory[source]?.filter { $0 > dayAgo }\n                if self.failureHistory[source]?.isEmpty == true {\n                    self.failureHistory.removeValue(forKey: source)\n                }\n            }\n            \n            print(\"🧹 Security monitoring cleanup completed\")\n        }\n    }\n    \n    private func updateMetrics() {\n        queue.async {\n            let metrics = self.calculateMetrics()\n            DispatchQueue.main.async {\n                self.currentMetrics = metrics\n            }\n        }\n    }\n}\n\n// MARK: - Security Monitor Extensions\n\nextension SecurityMonitor {\n    /// Quick threat level assessment\n    func getThreatLevel() -> SecurityEvent.SecuritySeverity {\n        let metrics = currentMetrics\n        \n        if metrics.systemHealth == .underAttack {\n            return .critical\n        } else if metrics.systemHealth == .critical {\n            return .high\n        } else if metrics.systemHealth == .warning {\n            return .medium\n        } else {\n            return .low\n        }\n    }\n    \n    /// Get top attacking sources\n    func getTopAttackers(limit: Int = 10) -> [(String, Int)] {\n        return Array(currentMetrics.topSources.sorted { $0.value > $1.value }.prefix(limit))\n    }\n    \n    /// Generate security report\n    func generateSecurityReport(period: TimeInterval = 86400) -> String {\n        let metrics = getSecurityMetrics()\n        let startDate = Date().addingTimeInterval(-period)\n        \n        return \"\"\"\n        Security Report (\\(startDate) - \\(Date()))\n        ==========================================\n        \n        Summary:\n        - Total Threats: \\(metrics.totalThreats)\n        - Threats Blocked: \\(metrics.threatsBlocked)\n        - Critical Threats: \\(metrics.criticalThreats)\n        - System Health: \\(metrics.systemHealth)\n        \n        Top Threat Types:\n        \\(metrics.topThreatTypes.map { \"- \\($0.key.rawValue): \\($0.value)\" }.joined(separator: \"\\n\"))\n        \n        Top Sources:\n        \\(metrics.topSources.prefix(5).map { \"- \\($0.key): \\($0.value)\" }.joined(separator: \"\\n\"))\n        \n        Blocked Sources: \\(blockedSources.count)\n        \"\"\"\n    }\n}\n"