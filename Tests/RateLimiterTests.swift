//\n//  RateLimiterTests.swift\n//  UniversalTranslatorTests\n//\n//  Comprehensive test suite for RateLimiter covering sliding window,\n//  burst handling, concurrent requests, and adaptive throttling.\n//\n\nimport XCTest\nimport Foundation\nimport Combine\n@testable import UniversalTranslator\n\nclass RateLimiterTests: XCTestCase {\n    var rateLimiter: RateLimiter!\n    var cancellables: Set<AnyCancellable>!\n    \n    override func setUp() {\n        super.setUp()\n        rateLimiter = RateLimiter(config: .default)\n        cancellables = Set<AnyCancellable>()\n    }\n    \n    override func tearDown() {\n        rateLimiter = nil\n        cancellables?.removeAll()\n        cancellables = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Basic Rate Limiting Tests\n    \n    func testBasicRateLimitAllowance() {\n        // Given\n        let identifier = \"test-user-1\"\n        \n        // When & Then - Should allow initial requests\n        for i in 1...30 {\n            let allowed = rateLimiter.isRequestAllowed(for: identifier)\n            XCTAssertTrue(allowed, \"Request \\(i) should be allowed\")\n            if allowed {\n                rateLimiter.recordRequest(for: identifier)\n            }\n        }\n    }\n    \n    func testRateLimitExceeded() {\n        // Given\n        let identifier = \"heavy-user\"\n        let config = RateLimitConfig(requestsPerMinute: 10, requestsPerHour: 100, requestsPerDay: 1000, burstAllowance: 5, windowSize: 60.0, suspiciousThreshold: 20, blacklistDuration: 300.0)\n        rateLimiter.updateConfig(config)\n        \n        // When - Make requests up to the limit\n        var allowedRequests = 0\n        for _ in 1...20 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n                allowedRequests += 1\n            }\n        }\n        \n        // Then - Should hit rate limit\n        XCTAssertLessThanOrEqual(allowedRequests, 15) // 10 regular + 5 burst tokens max\n        \n        // Additional request should be denied\n        XCTAssertFalse(rateLimiter.isRequestAllowed(for: identifier))\n    }\n    \n    func testBurstTokenUsage() {\n        // Given\n        let identifier = \"burst-user\"\n        let config = RateLimitConfig(requestsPerMinute: 5, requestsPerHour: 100, requestsPerDay: 1000, burstAllowance: 3, windowSize: 60.0, suspiciousThreshold: 20, blacklistDuration: 300.0)\n        rateLimiter.updateConfig(config)\n        \n        // When - Quickly make requests exceeding per-minute limit\n        var successfulRequests = 0\n        for _ in 1...10 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n                successfulRequests += 1\n            }\n        }\n        \n        // Then - Should allow regular + burst tokens\n        XCTAssertEqual(successfulRequests, 8) // 5 regular + 3 burst\n        \n        // Next request should be denied (no burst tokens left)\n        XCTAssertFalse(rateLimiter.isRequestAllowed(for: identifier))\n    }\n    \n    // MARK: - Multi-User Rate Limiting Tests\n    \n    func testIndependentUserRateLimits() {\n        // Given\n        let user1 = \"user-1\"\n        let user2 = \"user-2\"\n        let config = RateLimitConfig(requestsPerMinute: 5, requestsPerHour: 50, requestsPerDay: 500, burstAllowance: 2, windowSize: 60.0, suspiciousThreshold: 15, blacklistDuration: 300.0)\n        rateLimiter.updateConfig(config)\n        \n        // When - Exhaust user1's rate limit\n        for _ in 1...8 {\n            if rateLimiter.isRequestAllowed(for: user1) {\n                rateLimiter.recordRequest(for: user1)\n            }\n        }\n        \n        // Then\n        XCTAssertFalse(rateLimiter.isRequestAllowed(for: user1)) // User1 should be limited\n        XCTAssertTrue(rateLimiter.isRequestAllowed(for: user2)) // User2 should still be allowed\n    }\n    \n    func testRateLimitStatusTracking() {\n        // Given\n        let identifier = \"status-test-user\"\n        \n        // When - Make some requests\n        for _ in 1...5 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n            }\n        }\n        \n        let status = rateLimiter.getRateLimitStatus(for: identifier)\n        \n        // Then\n        XCTAssertEqual(status.identifier, identifier)\n        XCTAssertEqual(status.requestsInLastMinute, 5)\n        XCTAssertGreaterThan(status.remainingRequests, 0)\n        XCTAssertFalse(status.isBlacklisted)\n    }\n    \n    // MARK: - Blacklist Management Tests\n    \n    func testManualBlacklisting() {\n        // Given\n        let identifier = \"bad-actor\"\n        \n        // When\n        rateLimiter.blacklist(identifier, duration: 300.0)\n        \n        // Then\n        XCTAssertTrue(rateLimiter.isBlacklisted(identifier))\n        XCTAssertFalse(rateLimiter.isRequestAllowed(for: identifier))\n        \n        let status = rateLimiter.getRateLimitStatus(for: identifier)\n        XCTAssertTrue(status.isBlacklisted)\n    }\n    \n    func testBlacklistRemoval() {\n        // Given\n        let identifier = \"reformed-user\"\n        rateLimiter.blacklist(identifier)\n        XCTAssertTrue(rateLimiter.isBlacklisted(identifier))\n        \n        // When\n        rateLimiter.removeFromBlacklist(identifier)\n        \n        // Then\n        XCTAssertFalse(rateLimiter.isBlacklisted(identifier))\n        XCTAssertTrue(rateLimiter.isRequestAllowed(for: identifier))\n    }\n    \n    func testSuspiciousActivityDetection() {\n        // Given\n        let identifier = \"suspicious-user\"\n        let config = RateLimitConfig(requestsPerMinute: 100, requestsPerHour: 1000, requestsPerDay: 5000, burstAllowance: 20, windowSize: 60.0, suspiciousThreshold: 20, blacklistDuration: 600.0)\n        rateLimiter.updateConfig(config)\n        \n        // When - Simulate suspicious rapid-fire requests\n        var detectedSuspicious = false\n        for _ in 1...25 {\n            let allowed = rateLimiter.isRequestAllowed(for: identifier)\n            if allowed {\n                rateLimiter.recordRequest(for: identifier)\n            } else {\n                detectedSuspicious = true\n                break\n            }\n        }\n        \n        // Then - Should detect suspicious activity and blacklist\n        XCTAssertTrue(detectedSuspicious || rateLimiter.isBlacklisted(identifier))\n    }\n    \n    // MARK: - Time Window Tests\n    \n    func testSlidingWindowBehavior() {\n        // Given\n        let identifier = \"window-test-user\"\n        let config = RateLimitConfig(requestsPerMinute: 10, requestsPerHour: 100, requestsPerDay: 1000, burstAllowance: 0, windowSize: 5.0, suspiciousThreshold: 50, blacklistDuration: 300.0)\n        rateLimiter.updateConfig(config)\n        \n        // When - Fill up the rate limit\n        var initialRequests = 0\n        for _ in 1...15 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n                initialRequests += 1\n            }\n        }\n        \n        XCTAssertLessThanOrEqual(initialRequests, 10)\n        XCTAssertFalse(rateLimiter.isRequestAllowed(for: identifier))\n        \n        // Wait for window to slide (in real test, this would be time-based)\n        // For unit tests, we'll just verify the window logic works\n        let status = rateLimiter.getRateLimitStatus(for: identifier)\n        XCTAssertEqual(status.requestsInLastMinute, initialRequests)\n    }\n    \n    // MARK: - Configuration Management Tests\n    \n    func testConfigurationUpdate() {\n        // Given\n        let identifier = \"config-test-user\"\n        let strictConfig = RateLimitConfig(requestsPerMinute: 2, requestsPerHour: 10, requestsPerDay: 50, burstAllowance: 1, windowSize: 60.0, suspiciousThreshold: 10, blacklistDuration: 1800.0)\n        \n        // When\n        rateLimiter.updateConfig(strictConfig)\n        \n        // Then - Should apply new limits\n        var allowedRequests = 0\n        for _ in 1...5 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n                allowedRequests += 1\n            }\n        }\n        \n        XCTAssertLessThanOrEqual(allowedRequests, 3) // 2 regular + 1 burst\n    }\n    \n    func testDefaultVsPremiumConfiguration() {\n        // Given\n        let defaultUser = \"default-user\"\n        let premiumUser = \"premium-user\"\n        \n        // When - Test with default config\n        rateLimiter.updateConfig(.default)\n        let defaultAllowed = (1...70).compactMap { _ in\n            rateLimiter.isRequestAllowed(for: defaultUser) ? 1 : nil\n        }.count\n        \n        // Reset and test with premium config\n        rateLimiter.updateConfig(.premium)\n        let premiumAllowed = (1...130).compactMap { _ in\n            rateLimiter.isRequestAllowed(for: premiumUser) ? 1 : nil\n        }.count\n        \n        // Then\n        XCTAssertGreaterThan(premiumAllowed, defaultAllowed)\n    }\n    \n    // MARK: - API Integration Tests\n    \n    func testAPIRateLimitCheck() {\n        // Given\n        let userID = \"api-user-123\"\n        let endpoint = \"/api/translate\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/translate\")!)\n        \n        // When\n        let allowed = rateLimiter.checkAPIRateLimit(userID: userID, endpoint: endpoint, request: request)\n        \n        // Then\n        XCTAssertTrue(allowed)\n        \n        let status = rateLimiter.getRateLimitStatus(for: \"api:\\(userID)\")\n        XCTAssertEqual(status.requestsInLastMinute, 1)\n    }\n    \n    func testIPBasedRateLimit() {\n        // Given\n        let ipAddress = \"192.168.1.100\"\n        let endpoint = \"/api/public\"\n        \n        // When\n        let allowed1 = rateLimiter.checkIPRateLimit(ipAddress, endpoint: endpoint)\n        let allowed2 = rateLimiter.checkIPRateLimit(ipAddress, endpoint: endpoint)\n        \n        // Then\n        XCTAssertTrue(allowed1)\n        XCTAssertTrue(allowed2)\n        \n        let status = rateLimiter.getRateLimitStatus(for: \"ip:\\(ipAddress)\")\n        XCTAssertEqual(status.requestsInLastMinute, 2)\n    }\n    \n    func testCombinedRateLimit() {\n        // Given\n        let userID = \"combined-user\"\n        let ipAddress = \"10.0.0.1\"\n        let endpoint = \"/api/secure\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/secure\")!)\n        \n        // When\n        let allowed = rateLimiter.checkCombinedRateLimit(\n            userID: userID,\n            ipAddress: ipAddress,\n            endpoint: endpoint,\n            request: request\n        )\n        \n        // Then\n        XCTAssertTrue(allowed)\n        \n        // Both IP and user should be tracked\n        let ipStatus = rateLimiter.getRateLimitStatus(for: \"ip:\\(ipAddress)\")\n        let userStatus = rateLimiter.getRateLimitStatus(for: \"api:\\(userID)\")\n        XCTAssertEqual(ipStatus.requestsInLastMinute, 1)\n        XCTAssertEqual(userStatus.requestsInLastMinute, 1)\n    }\n    \n    // MARK: - Concurrent Request Handling Tests\n    \n    func testConcurrentRequestHandling() async {\n        // Given\n        let handler = ConcurrentRateLimitHandler(rateLimiter: rateLimiter, maxConcurrentRequests: 5)\n        let identifier = \"concurrent-user\"\n        \n        // When - Make concurrent requests\n        let tasks = (1...10).map { i in\n            Task {\n                do {\n                    let result = try await handler.performRequest(identifier: identifier) {\n                        // Simulate some work\n                        try await Task.sleep(nanoseconds: 100_000_000) // 100ms\n                        return \"Result \\(i)\"\n                    }\n                    return (true, result)\n                } catch {\n                    return (false, error.localizedDescription)\n                }\n            }\n        }\n        \n        let results = await withTaskGroup(of: (Bool, String).self) { group in\n            for task in tasks {\n                group.addTask {\n                    await task.value\n                }\n            }\n            \n            var results: [(Bool, String)] = []\n            for await result in group {\n                results.append(result)\n            }\n            return results\n        }\n        \n        // Then - Some requests should succeed, some might be rate limited\n        let successful = results.filter { $0.0 }.count\n        let rateLimited = results.filter { !$0.0 }.count\n        \n        XCTAssertGreaterThan(successful, 0)\n        print(\"Successful: \\(successful), Rate Limited: \\(rateLimited)\")\n    }\n    \n    func testConcurrentRequestSemaphore() async {\n        // Given\n        let handler = ConcurrentRateLimitHandler(rateLimiter: rateLimiter, maxConcurrentRequests: 3)\n        let identifier = \"semaphore-test\"\n        var concurrentCount = 0\n        var maxConcurrent = 0\n        let lock = NSLock()\n        \n        // When\n        let tasks = (1...8).map { i in\n            Task {\n                do {\n                    let result = try await handler.performRequest(identifier: identifier) {\n                        lock.lock()\n                        concurrentCount += 1\n                        maxConcurrent = max(maxConcurrent, concurrentCount)\n                        lock.unlock()\n                        \n                        try await Task.sleep(nanoseconds: 200_000_000) // 200ms\n                        \n                        lock.lock()\n                        concurrentCount -= 1\n                        lock.unlock()\n                        \n                        return \"Task \\(i)\"\n                    }\n                    return result\n                } catch {\n                    return \"Error: \\(error)\"\n                }\n            }\n        }\n        \n        let _ = await withTaskGroup(of: String.self) { group in\n            for task in tasks {\n                group.addTask {\n                    await task.value\n                }\n            }\n            \n            var results: [String] = []\n            for await result in group {\n                results.append(result)\n            }\n            return results\n        }\n        \n        // Then - Should not exceed max concurrent limit\n        XCTAssertLessThanOrEqual(maxConcurrent, 3)\n    }\n    \n    // MARK: - Metrics and Monitoring Tests\n    \n    func testRateLimiterMetrics() {\n        // Given\n        let users = [\"user1\", \"user2\", \"user3\"]\n        \n        // When - Generate some activity\n        for user in users {\n            for _ in 1...5 {\n                if rateLimiter.isRequestAllowed(for: user) {\n                    rateLimiter.recordRequest(for: user)\n                }\n            }\n        }\n        \n        // Block one user\n        rateLimiter.blacklist(\"user2\")\n        \n        // Then - Check metrics\n        XCTAssertGreaterThan(rateLimiter.totalRequestsToday, 0)\n        XCTAssertGreaterThan(rateLimiter.activeUsers, 0)\n        XCTAssertGreaterThan(rateLimiter.blockedRequests, 0)\n    }\n    \n    func testAllRateLimitStatuses() {\n        // Given\n        let users = [\"stats1\", \"stats2\", \"stats3\"]\n        \n        for user in users {\n            for _ in 1...3 {\n                if rateLimiter.isRequestAllowed(for: user) {\n                    rateLimiter.recordRequest(for: user)\n                }\n            }\n        }\n        \n        // When\n        let allStatuses = rateLimiter.getAllRateLimitStatuses()\n        \n        // Then\n        XCTAssertEqual(allStatuses.count, users.count)\n        for status in allStatuses {\n            XCTAssertTrue(users.contains(status.identifier))\n            XCTAssertEqual(status.requestsInLastMinute, 3)\n        }\n    }\n    \n    // MARK: - Reset and Cleanup Tests\n    \n    func testRateLimitReset() {\n        // Given\n        let identifier = \"reset-user\"\n        \n        // Make some requests and blacklist\n        for _ in 1...5 {\n            if rateLimiter.isRequestAllowed(for: identifier) {\n                rateLimiter.recordRequest(for: identifier)\n            }\n        }\n        rateLimiter.blacklist(identifier)\n        \n        let statusBefore = rateLimiter.getRateLimitStatus(for: identifier)\n        XCTAssertTrue(statusBefore.isBlacklisted)\n        XCTAssertGreaterThan(statusBefore.requestsInLastMinute, 0)\n        \n        // When\n        rateLimiter.resetRateLimit(for: identifier)\n        \n        // Then\n        let statusAfter = rateLimiter.getRateLimitStatus(for: identifier)\n        XCTAssertFalse(statusAfter.isBlacklisted)\n        XCTAssertEqual(statusAfter.requestsInLastMinute, 0)\n        XCTAssertTrue(rateLimiter.isRequestAllowed(for: identifier))\n    }\n    \n    // MARK: - Edge Cases and Error Handling Tests\n    \n    func testEmptyIdentifierHandling() {\n        // Given\n        let emptyIdentifier = \"\"\n        \n        // When & Then - Should handle gracefully\n        XCTAssertTrue(rateLimiter.isRequestAllowed(for: emptyIdentifier))\n        rateLimiter.recordRequest(for: emptyIdentifier)\n        \n        let status = rateLimiter.getRateLimitStatus(for: emptyIdentifier)\n        XCTAssertEqual(status.identifier, emptyIdentifier)\n    }\n    \n    func testVeryLongIdentifierHandling() {\n        // Given\n        let longIdentifier = String(repeating: \"a\", count: 1000)\n        \n        // When & Then - Should handle gracefully\n        XCTAssertTrue(rateLimiter.isRequestAllowed(for: longIdentifier))\n        rateLimiter.recordRequest(for: longIdentifier)\n        \n        let status = rateLimiter.getRateLimitStatus(for: longIdentifier)\n        XCTAssertEqual(status.identifier, longIdentifier)\n    }\n    \n    func testSpecialCharacterIdentifiers() {\n        // Given\n        let specialIdentifiers = [\n            \"user@domain.com\",\n            \"192.168.1.1\",\n            \"user-with-dashes\",\n            \"user_with_underscores\",\n            \"ç”¨æˆ·123\", // Unicode\n            \"ðŸš€rocketðŸš€\" // Emojis\n        ]\n        \n        // When & Then\n        for identifier in specialIdentifiers {\n            XCTAssertTrue(rateLimiter.isRequestAllowed(for: identifier), \"Failed for identifier: \\(identifier)\")\n            rateLimiter.recordRequest(for: identifier)\n            \n            let status = rateLimiter.getRateLimitStatus(for: identifier)\n            XCTAssertEqual(status.identifier, identifier)\n        }\n    }\n    \n    // MARK: - Performance Tests\n    \n    func testRateLimitPerformance() {\n        // Given\n        let identifiers = (1...100).map { \"user\\($0)\" }\n        \n        // When & Then\n        measure {\n            for identifier in identifiers {\n                _ = rateLimiter.isRequestAllowed(for: identifier)\n                rateLimiter.recordRequest(for: identifier)\n            }\n        }\n    }\n    \n    func testConcurrentPerformance() {\n        // Given\n        let expectation = expectation(description: \"Concurrent rate limiting\")\n        expectation.expectedFulfillmentCount = 50\n        \n        let queue = DispatchQueue(label: \"rate-limit-test\", attributes: .concurrent)\n        \n        // When\n        for i in 1...50 {\n            queue.async {\n                let identifier = \"perf-user-\\(i % 10)\" // 10 different users\n                _ = self.rateLimiter.isRequestAllowed(for: identifier)\n                self.rateLimiter.recordRequest(for: identifier)\n                expectation.fulfill()\n            }\n        }\n        \n        // Then\n        waitForExpectations(timeout: 5.0)\n    }\n}\n"