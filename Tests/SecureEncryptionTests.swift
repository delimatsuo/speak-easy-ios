//\n//  SecureEncryptionTests.swift\n//  UniversalTranslatorTests\n//\n//  Comprehensive test suite for SecureEncryption covering AES-256-GCM,\n//  key derivation, keychain integration, and security edge cases.\n//\n\nimport XCTest\nimport CryptoKit\nimport Security\n@testable import UniversalTranslator\n\nclass SecureEncryptionTests: XCTestCase {\n    var secureEncryption: SecureEncryption!\n    \n    override func setUp() {\n        super.setUp()\n        secureEncryption = SecureEncryption.shared\n        \n        // Clean up keychain before each test\n        try? secureEncryption.deleteKey(withIdentifier: \"test-key\")\n    }\n    \n    override func tearDown() {\n        // Clean up keychain after each test\n        try? secureEncryption.deleteKey(withIdentifier: \"test-key\")\n        secureEncryption = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Key Generation Tests\n    \n    func testKeyGeneration() {\n        // When\n        let key1 = try! secureEncryption.generateKey()\n        let key2 = try! secureEncryption.generateKey()\n        \n        // Then\n        XCTAssertNotEqual(key1.withUnsafeBytes { Data($0) }, key2.withUnsafeBytes { Data($0) })\n        XCTAssertEqual(key1.withUnsafeBytes { $0.count }, 32) // AES-256\n        XCTAssertEqual(key2.withUnsafeBytes { $0.count }, 32)\n    }\n    \n    func testKeyDerivationFromPassword() {\n        // Given\n        let password = \"SecurePassword123!\"\n        let salt = secureEncryption.generateSalt()\n        \n        // When\n        let derivedKey1 = try! secureEncryption.deriveKey(from: password, salt: salt)\n        let derivedKey2 = try! secureEncryption.deriveKey(from: password, salt: salt)\n        \n        // Then\n        XCTAssertEqual(\n            derivedKey1.withUnsafeBytes { Data($0) },\n            derivedKey2.withUnsafeBytes { Data($0) }\n        )\n        XCTAssertEqual(derivedKey1.withUnsafeBytes { $0.count }, 32)\n    }\n    \n    func testKeyDerivationWithDifferentSalts() {\n        // Given\n        let password = \"SamePassword123!\"\n        let salt1 = secureEncryption.generateSalt()\n        let salt2 = secureEncryption.generateSalt()\n        \n        // When\n        let derivedKey1 = try! secureEncryption.deriveKey(from: password, salt: salt1)\n        let derivedKey2 = try! secureEncryption.deriveKey(from: password, salt: salt2)\n        \n        // Then\n        XCTAssertNotEqual(\n            derivedKey1.withUnsafeBytes { Data($0) },\n            derivedKey2.withUnsafeBytes { Data($0) }\n        )\n    }\n    \n    func testKeyDerivationWithInvalidPassword() {\n        // Given\n        let invalidPassword = \"\"\n        let salt = secureEncryption.generateSalt()\n        \n        // When\n        let derivedKey = try! secureEncryption.deriveKey(from: invalidPassword, salt: salt)\n        \n        // Then\n        XCTAssertEqual(derivedKey.withUnsafeBytes { $0.count }, 32)\n    }\n    \n    func testSaltGeneration() {\n        // When\n        let salt1 = secureEncryption.generateSalt()\n        let salt2 = secureEncryption.generateSalt()\n        \n        // Then\n        XCTAssertNotEqual(salt1, salt2)\n        XCTAssertEqual(salt1.count, 16) // Expected salt size\n        XCTAssertEqual(salt2.count, 16)\n    }\n    \n    // MARK: - Encryption/Decryption Tests\n    \n    func testBasicEncryptionDecryption() {\n        // Given\n        let plaintext = \"Hello, World!\".data(using: .utf8)!\n        let key = try! secureEncryption.generateKey()\n        \n        // When\n        let encrypted = try! secureEncryption.encrypt(plaintext, with: key)\n        let decrypted = try! secureEncryption.decrypt(encrypted, with: key)\n        \n        // Then\n        XCTAssertNotEqual(encrypted.ciphertext, plaintext)\n        XCTAssertEqual(decrypted, plaintext)\n        XCTAssertEqual(encrypted.nonce.count, 12) // AES-GCM nonce size\n        XCTAssertEqual(encrypted.tag.count, 16) // AES-GCM tag size\n        XCTAssertNil(encrypted.salt) // No salt for key-based encryption\n    }\n    \n    func testLargeDataEncryption() {\n        // Given\n        let largeData = Data(repeating: 0xFF, count: 1024 * 1024) // 1MB\n        let key = try! secureEncryption.generateKey()\n        \n        // When\n        let encrypted = try! secureEncryption.encrypt(largeData, with: key)\n        let decrypted = try! secureEncryption.decrypt(encrypted, with: key)\n        \n        // Then\n        XCTAssertEqual(decrypted, largeData)\n        XCTAssertEqual(encrypted.ciphertext.count, largeData.count)\n    }\n    \n    func testPasswordBasedEncryption() {\n        // Given\n        let plaintext = \"Sensitive information here\".data(using: .utf8)!\n        let password = \"MySecurePassword123!\"\n        \n        // When\n        let encrypted = try! secureEncryption.encrypt(plaintext, with: password)\n        let decrypted = try! secureEncryption.decrypt(encrypted, with: password)\n        \n        // Then\n        XCTAssertEqual(decrypted, plaintext)\n        XCTAssertNotNil(encrypted.salt) // Salt should be present for password-based encryption\n        XCTAssertEqual(encrypted.salt?.count, 16)\n    }\n    \n    func testEncryptionWithDifferentKeys() {\n        // Given\n        let plaintext = \"Test data\".data(using: .utf8)!\n        let key1 = try! secureEncryption.generateKey()\n        let key2 = try! secureEncryption.generateKey()\n        \n        // When\n        let encrypted = try! secureEncryption.encrypt(plaintext, with: key1)\n        \n        // Then - Should fail with different key\n        XCTAssertThrowsError(try secureEncryption.decrypt(encrypted, with: key2)) { error in\n            XCTAssertTrue(error is EncryptionError)\n            if case EncryptionError.authenticationFailed = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected authenticationFailed error\")\n            }\n        }\n    }\n    \n    func testDecryptionWithTamperedCiphertext() {\n        // Given\n        let plaintext = \"Original data\".data(using: .utf8)!\n        let key = try! secureEncryption.generateKey()\n        var encrypted = try! secureEncryption.encrypt(plaintext, with: key)\n        \n        // When - Tamper with ciphertext\n        var tamperedCiphertext = encrypted.ciphertext\n        tamperedCiphertext[0] = tamperedCiphertext[0] ^ 0xFF\n        encrypted = EncryptedData(\n            ciphertext: tamperedCiphertext,\n            nonce: encrypted.nonce,\n            salt: encrypted.salt,\n            tag: encrypted.tag\n        )\n        \n        // Then - Should fail authentication\n        XCTAssertThrowsError(try secureEncryption.decrypt(encrypted, with: key)) { error in\n            if case EncryptionError.authenticationFailed = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected authenticationFailed error, got \\(error)\")\n            }\n        }\n    }\n    \n    func testDecryptionWithTamperedTag() {\n        // Given\n        let plaintext = \"Original data\".data(using: .utf8)!\n        let key = try! secureEncryption.generateKey()\n        var encrypted = try! secureEncryption.encrypt(plaintext, with: key)\n        \n        // When - Tamper with tag\n        var tamperedTag = encrypted.tag\n        tamperedTag[0] = tamperedTag[0] ^ 0xFF\n        encrypted = EncryptedData(\n            ciphertext: encrypted.ciphertext,\n            nonce: encrypted.nonce,\n            salt: encrypted.salt,\n            tag: tamperedTag\n        )\n        \n        // Then - Should fail authentication\n        XCTAssertThrowsError(try secureEncryption.decrypt(encrypted, with: key)) { error in\n            if case EncryptionError.authenticationFailed = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected authenticationFailed error\")\n            }\n        }\n    }\n    \n    func testEncryptionOfEmptyData() {\n        // Given\n        let emptyData = Data()\n        let key = try! secureEncryption.generateKey()\n        \n        // When & Then\n        XCTAssertThrowsError(try secureEncryption.encrypt(emptyData, with: key)) { error in\n            if case EncryptionError.invalidData = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected invalidData error\")\n            }\n        }\n    }\n    \n    // MARK: - Serialization Tests\n    \n    func testEncryptedDataSerialization() {\n        // Given\n        let plaintext = \"Test serialization\".data(using: .utf8)!\n        let password = \"TestPassword123\"\n        \n        // When\n        let encrypted = try! secureEncryption.encrypt(plaintext, with: password)\n        let serialized = encrypted.serialize()\n        let deserialized = try! EncryptedData.deserialize(serialized)\n        let decrypted = try! secureEncryption.decrypt(deserialized, with: password)\n        \n        // Then\n        XCTAssertEqual(decrypted, plaintext)\n        XCTAssertEqual(deserialized.ciphertext, encrypted.ciphertext)\n        XCTAssertEqual(deserialized.nonce, encrypted.nonce)\n        XCTAssertEqual(deserialized.salt, encrypted.salt)\n        XCTAssertEqual(deserialized.tag, encrypted.tag)\n    }\n    \n    func testSerializationWithInvalidData() {\n        // Given\n        let invalidData = Data([0x01, 0x02, 0x03]) // Too short\n        \n        // When & Then\n        XCTAssertThrowsError(try EncryptedData.deserialize(invalidData)) { error in\n            if case EncryptionError.invalidData = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected invalidData error\")\n            }\n        }\n    }\n    \n    // MARK: - Keychain Integration Tests\n    \n    func testKeychainStorageAndRetrieval() {\n        // Given\n        let key = try! secureEncryption.generateKey()\n        let identifier = \"test-key\"\n        \n        // When\n        try! secureEncryption.storeKey(key, withIdentifier: identifier)\n        let retrievedKey = try! secureEncryption.retrieveKey(withIdentifier: identifier)\n        \n        // Then\n        XCTAssertEqual(\n            key.withUnsafeBytes { Data($0) },\n            retrievedKey.withUnsafeBytes { Data($0) }\n        )\n    }\n    \n    func testKeychainKeyDeletion() {\n        // Given\n        let key = try! secureEncryption.generateKey()\n        let identifier = \"test-key-to-delete\"\n        \n        // When\n        try! secureEncryption.storeKey(key, withIdentifier: identifier)\n        try! secureEncryption.deleteKey(withIdentifier: identifier)\n        \n        // Then\n        XCTAssertThrowsError(try secureEncryption.retrieveKey(withIdentifier: identifier)) { error in\n            if case EncryptionError.keychainError(let status) = error {\n                XCTAssertEqual(status, errSecItemNotFound)\n            } else {\n                XCTFail(\"Expected keychainError with errSecItemNotFound\")\n            }\n        }\n    }\n    \n    func testKeychainKeyOverwrite() {\n        // Given\n        let key1 = try! secureEncryption.generateKey()\n        let key2 = try! secureEncryption.generateKey()\n        let identifier = \"test-key-overwrite\"\n        \n        // When\n        try! secureEncryption.storeKey(key1, withIdentifier: identifier)\n        try! secureEncryption.storeKey(key2, withIdentifier: identifier) // Should overwrite\n        let retrievedKey = try! secureEncryption.retrieveKey(withIdentifier: identifier)\n        \n        // Then\n        XCTAssertEqual(\n            key2.withUnsafeBytes { Data($0) },\n            retrievedKey.withUnsafeBytes { Data($0) }\n        )\n        XCTAssertNotEqual(\n            key1.withUnsafeBytes { Data($0) },\n            retrievedKey.withUnsafeBytes { Data($0) }\n        )\n    }\n    \n    func testRetrieveNonExistentKey() {\n        // Given\n        let nonExistentIdentifier = \"non-existent-key\"\n        \n        // When & Then\n        XCTAssertThrowsError(try secureEncryption.retrieveKey(withIdentifier: nonExistentIdentifier)) { error in\n            if case EncryptionError.keychainError(let status) = error {\n                XCTAssertEqual(status, errSecItemNotFound)\n            } else {\n                XCTFail(\"Expected keychainError with errSecItemNotFound\")\n            }\n        }\n    }\n    \n    // MARK: - Utility Methods Tests\n    \n    func testRandomDataGeneration() {\n        // When\n        let data1 = secureEncryption.generateRandomData(length: 32)\n        let data2 = secureEncryption.generateRandomData(length: 32)\n        let data3 = secureEncryption.generateRandomData(length: 16)\n        \n        // Then\n        XCTAssertNotEqual(data1, data2) // Should be unique\n        XCTAssertEqual(data1.count, 32)\n        XCTAssertEqual(data2.count, 32)\n        XCTAssertEqual(data3.count, 16)\n    }\n    \n    func testDataHashing() {\n        // Given\n        let data = \"Test data for hashing\".data(using: .utf8)!\n        \n        // When\n        let hash1 = secureEncryption.hash(data)\n        let hash2 = secureEncryption.hash(data)\n        let hash3 = secureEncryption.hash(\"Different data\".data(using: .utf8)!)\n        \n        // Then\n        XCTAssertEqual(hash1, hash2) // Same data should produce same hash\n        XCTAssertNotEqual(hash1, hash3) // Different data should produce different hash\n        XCTAssertEqual(hash1.count, 32) // SHA-256 produces 32-byte hash\n    }\n    \n    func testConstantTimeComparison() {\n        // Given\n        let data1 = Data([0x01, 0x02, 0x03, 0x04])\n        let data2 = Data([0x01, 0x02, 0x03, 0x04])\n        let data3 = Data([0x01, 0x02, 0x03, 0x05])\n        let data4 = Data([0x01, 0x02, 0x03]) // Different length\n        \n        // When & Then\n        XCTAssertTrue(secureEncryption.constantTimeCompare(data1, data2))\n        XCTAssertFalse(secureEncryption.constantTimeCompare(data1, data3))\n        XCTAssertFalse(secureEncryption.constantTimeCompare(data1, data4))\n    }\n    \n    func testSecureMemoryWipe() {\n        // Given\n        var data = \"Sensitive data that should be wiped\".data(using: .utf8)!\n        let originalData = data\n        \n        // When\n        secureEncryption.secureWipe(&data)\n        \n        // Then\n        XCTAssertNotEqual(data, originalData)\n        XCTAssertTrue(data.allSatisfy { $0 == 0 }) // Should be all zeros\n    }\n    \n    // MARK: - String Convenience Methods Tests\n    \n    func testStringEncryptionDecryption() {\n        // Given\n        let originalString = \"Hello, 世界! 🌍 Special chars: @#$%^&*()\"\n        let password = \"StringTestPassword123!\"\n        \n        // When\n        let encryptedData = try! secureEncryption.encrypt(originalString, with: password)\n        let decryptedString = try! secureEncryption.decryptString(encryptedData, with: password)\n        \n        // Then\n        XCTAssertEqual(decryptedString, originalString)\n    }\n    \n    func testStringDecryptionWithWrongPassword() {\n        // Given\n        let originalString = \"Secret message\"\n        let correctPassword = \"CorrectPassword123\"\n        let wrongPassword = \"WrongPassword456\"\n        \n        // When\n        let encryptedData = try! secureEncryption.encrypt(originalString, with: correctPassword)\n        \n        // Then\n        XCTAssertThrowsError(try secureEncryption.decryptString(encryptedData, with: wrongPassword)) { error in\n            XCTAssertTrue(error is EncryptionError)\n        }\n    }\n    \n    func testEmptyStringEncryption() {\n        // Given\n        let emptyString = \"\"\n        let password = \"TestPassword\"\n        \n        // When & Then\n        XCTAssertThrowsError(try secureEncryption.encrypt(emptyString, with: password)) { error in\n            if case EncryptionError.invalidData = error {\n                // Expected\n            } else {\n                XCTFail(\"Expected invalidData error\")\n            }\n        }\n    }\n    \n    // MARK: - Performance Tests\n    \n    func testEncryptionPerformance() {\n        // Given\n        let data = Data(repeating: 0xAB, count: 1024 * 100) // 100KB\n        let key = try! secureEncryption.generateKey()\n        \n        // When & Then\n        measure {\n            _ = try! secureEncryption.encrypt(data, with: key)\n        }\n    }\n    \n    func testDecryptionPerformance() {\n        // Given\n        let data = Data(repeating: 0xCD, count: 1024 * 100) // 100KB\n        let key = try! secureEncryption.generateKey()\n        let encrypted = try! secureEncryption.encrypt(data, with: key)\n        \n        // When & Then\n        measure {\n            _ = try! secureEncryption.decrypt(encrypted, with: key)\n        }\n    }\n    \n    func testKeyDerivationPerformance() {\n        // Given\n        let password = \"TestPassword123!\"\n        let salt = secureEncryption.generateSalt()\n        \n        // When & Then\n        measure {\n            _ = try! secureEncryption.deriveKey(from: password, salt: salt)\n        }\n    }\n    \n    // MARK: - Edge Cases and Boundary Tests\n    \n    func testVeryLongPasswordKeyDerivation() {\n        // Given\n        let longPassword = String(repeating: \"VeryLongPasswordWith1234567890!@#$%^&*()_+-=[]{}|;':\"\",./<>?\", count: 100)\n        let salt = secureEncryption.generateSalt()\n        \n        // When\n        let derivedKey = try! secureEncryption.deriveKey(from: longPassword, salt: salt)\n        \n        // Then\n        XCTAssertEqual(derivedKey.withUnsafeBytes { $0.count }, 32)\n    }\n    \n    func testUnicodePasswordKeyDerivation() {\n        // Given\n        let unicodePassword = \"密码123🔐🌍こんにちはПароль\"\n        let salt = secureEncryption.generateSalt()\n        \n        // When\n        let derivedKey = try! secureEncryption.deriveKey(from: unicodePassword, salt: salt)\n        \n        // Then\n        XCTAssertEqual(derivedKey.withUnsafeBytes { $0.count }, 32)\n        \n        // Should be reproducible\n        let derivedKey2 = try! secureEncryption.deriveKey(from: unicodePassword, salt: salt)\n        XCTAssertEqual(\n            derivedKey.withUnsafeBytes { Data($0) },\n            derivedKey2.withUnsafeBytes { Data($0) }\n        )\n    }\n    \n    func testConcurrentEncryptionOperations() {\n        // Given\n        let data = \"Concurrent test data\".data(using: .utf8)!\n        let key = try! secureEncryption.generateKey()\n        let expectation = expectation(description: \"Concurrent encryption\")\n        expectation.expectedFulfillmentCount = 10\n        \n        // When\n        let queue = DispatchQueue(label: \"concurrent-encryption\", attributes: .concurrent)\n        \n        for _ in 0..<10 {\n            queue.async {\n                do {\n                    let encrypted = try self.secureEncryption.encrypt(data, with: key)\n                    let decrypted = try self.secureEncryption.decrypt(encrypted, with: key)\n                    XCTAssertEqual(decrypted, data)\n                    expectation.fulfill()\n                } catch {\n                    XCTFail(\"Concurrent encryption failed: \\(error)\")\n                }\n            }\n        }\n        \n        // Then\n        waitForExpectations(timeout: 5.0)\n    }\n}\n"