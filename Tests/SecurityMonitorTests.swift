//\n//  SecurityMonitorTests.swift\n//  UniversalTranslatorTests\n//\n//  Comprehensive test suite for SecurityMonitor covering anomaly detection,\n//  threat intelligence, attack pattern recognition, and security metrics.\n//\n\nimport XCTest\nimport Foundation\nimport Network\nimport Combine\n@testable import UniversalTranslator\n\nclass SecurityMonitorTests: XCTestCase {\n    var securityMonitor: SecurityMonitor!\n    var cancellables: Set<AnyCancellable>!\n    \n    override func setUp() {\n        super.setUp()\n        securityMonitor = SecurityMonitor.shared\n        cancellables = Set<AnyCancellable>()\n        \n        // Reset monitor state for each test\n        let testConfig = AnomalyConfig(\n            requestThreshold: 10,\n            timeWindow: 300.0,\n            failureRateThreshold: 0.3,\n            patternDetectionEnabled: true,\n            mlDetectionEnabled: false,\n            geoLocationChecks: false\n        )\n        securityMonitor.updateConfig(testConfig)\n    }\n    \n    override func tearDown() {\n        securityMonitor = nil\n        cancellables?.removeAll()\n        cancellables = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Basic Request Analysis Tests\n    \n    func testCleanRequestAnalysis() {\n        // Given\n        let cleanURL = URL(string: \"https://api.example.com/translate\")!\n        let request = URLRequest(url: cleanURL)\n        let source = \"192.168.1.100\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertTrue(events.isEmpty, \"Clean request should not generate security events\")\n        XCTAssertFalse(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testBasicRequestRecording() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        let source = \"10.0.0.1\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        let metrics = securityMonitor.getSecurityMetrics()\n        \n        // Then\n        XCTAssertTrue(events.isEmpty)\n        XCTAssertEqual(metrics.systemHealth, .healthy)\n    }\n    \n    // MARK: - XSS Attack Detection Tests\n    \n    func testXSSAttackInURL() {\n        // Given\n        let maliciousURL = URL(string: \"https://api.example.com/search?q=<script>alert('XSS')</script>\")!\n        let request = URLRequest(url: maliciousURL)\n        let source = \"203.0.113.1\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let xssEvent = events.first { $0.threat == .xssAttack }\n        XCTAssertNotNil(xssEvent)\n        XCTAssertEqual(xssEvent?.severity, .high)\n        XCTAssertTrue(xssEvent?.blocked ?? false)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testXSSAttackInPayload() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/submit\")!)\n        let maliciousPayload = \"<script>document.cookie='stolen'</script>\".data(using: .utf8)!\n        let source = \"198.51.100.1\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: maliciousPayload)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let xssEvent = events.first { $0.threat == .xssAttack }\n        XCTAssertNotNil(xssEvent)\n        XCTAssertEqual(xssEvent?.severity, .high)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testJavaScriptProtocolAttack() {\n        // Given\n        let maliciousURL = URL(string: \"https://api.example.com/redirect?url=javascript:alert(1)\")!\n        let request = URLRequest(url: maliciousURL)\n        let source = \"192.0.2.1\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let xssEvent = events.first { $0.threat == .xssAttack }\n        XCTAssertNotNil(xssEvent)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    // MARK: - SQL Injection Detection Tests\n    \n    func testSQLInjectionInURL() {\n        // Given\n        let maliciousURL = URL(string: \"https://api.example.com/user?id=1'; DROP TABLE users; --\")!\n        let request = URLRequest(url: maliciousURL)\n        let source = \"203.0.113.2\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let sqlEvent = events.first { $0.threat == .sqlInjection }\n        XCTAssertNotNil(sqlEvent)\n        XCTAssertEqual(sqlEvent?.severity, .high)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testSQLInjectionInPayload() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/login\")!)\n        let maliciousPayload = \"username=admin&password=' UNION SELECT password FROM users WHERE id=1 --\".data(using: .utf8)!\n        let source = \"198.51.100.2\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: maliciousPayload)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let sqlEvent = events.first { $0.threat == .sqlInjection }\n        XCTAssertNotNil(sqlEvent)\n        XCTAssertEqual(sqlEvent?.severity, .critical)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    // MARK: - Command Injection Detection Tests\n    \n    func testCommandInjectionInPayload() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/system\")!)\n        let maliciousPayload = \"filename=test.txt; rm -rf /\".data(using: .utf8)!\n        let source = \"192.0.2.2\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: maliciousPayload)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let cmdEvent = events.first { $0.threat == .commandInjection }\n        XCTAssertNotNil(cmdEvent)\n        XCTAssertEqual(cmdEvent?.severity, .critical)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testPathTraversalAttack() {\n        // Given\n        let maliciousURL = URL(string: \"https://api.example.com/file?path=../../../etc/passwd\")!\n        let request = URLRequest(url: maliciousURL)\n        let source = \"203.0.113.3\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let cmdEvent = events.first { $0.threat == .commandInjection }\n        XCTAssertNotNil(cmdEvent)\n        XCTAssertEqual(cmdEvent?.severity, .high)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    // MARK: - Suspicious User Agent Detection Tests\n    \n    func testSuspiciousUserAgentDetection() {\n        // Given\n        let suspiciousUserAgents = [\n            \"sqlmap/1.5.2\",\n            \"Mozilla/5.0 (compatible; Nmap Scripting Engine)\",\n            \"nikto/2.1.6\",\n            \"w3af.sourceforge.net\",\n            \"Burp Suite Professional\"\n        ]\n        \n        let source = \"198.51.100.3\"\n        \n        // When & Then\n        for userAgent in suspiciousUserAgents {\n            var request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n            request.setValue(userAgent, forHTTPHeaderField: \"User-Agent\")\n            \n            let events = securityMonitor.analyzeRequest(request, source: source + userAgent.suffix(1))\n            \n            XCTAssertFalse(events.isEmpty, \"Should detect suspicious user agent: \\(userAgent)\")\n            let uaEvent = events.first { $0.threat == .suspiciousUserAgent }\n            XCTAssertNotNil(uaEvent, \"Should create suspicious user agent event for: \\(userAgent)\")\n            XCTAssertEqual(uaEvent?.severity, .medium)\n        }\n    }\n    \n    func testSuspiciousHeaderAnalysis() {\n        // Given\n        var request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        request.setValue(\"192.168.1.1, 10.0.0.1, 172.16.0.1, 203.0.113.1\", forHTTPHeaderField: \"X-Forwarded-For\")\n        let source = \"192.0.2.3\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        let suspiciousEvent = events.first { $0.threat == .suspiciousUserAgent }\n        XCTAssertNotNil(suspiciousEvent)\n        XCTAssertEqual(suspiciousEvent?.severity, .low)\n    }\n    \n    // MARK: - DDoS and Traffic Pattern Detection Tests\n    \n    func testDDoSDetection() {\n        // Given\n        let source = \"203.0.113.4\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When - Simulate rapid requests\n        var detectedDDoS = false\n        for _ in 1...15 { // Exceed the threshold of 10\n            let events = securityMonitor.analyzeRequest(request, source: source)\n            if events.contains(where: { $0.threat == .ddosAttack }) {\n                detectedDDoS = true\n                break\n            }\n        }\n        \n        // Then\n        XCTAssertTrue(detectedDDoS, \"Should detect DDoS pattern\")\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testBruteForceDetection() {\n        // Given\n        let source = \"198.51.100.4\"\n        \n        // When - Simulate multiple failures\n        for _ in 1...12 { // Exceed threshold of 10\n            securityMonitor.recordFailure(source: source, reason: \"Invalid credentials\")\n        }\n        \n        // Then\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n        \n        let events = securityMonitor.getRecentEvents()\n        let bruteForceEvent = events.first { $0.threat == .bruteForceAttack }\n        XCTAssertNotNil(bruteForceEvent)\n        XCTAssertEqual(bruteForceEvent?.severity, .high)\n    }\n    \n    func testAnomalousTrafficPattern() {\n        // Given\n        let source = \"192.0.2.4\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // First, make some requests to establish baseline\n        for _ in 1...5 {\n            _ = securityMonitor.analyzeRequest(request, source: source)\n        }\n        \n        // Then simulate many failures\n        for _ in 1...8 {\n            securityMonitor.recordFailure(source: source, reason: \"Authentication failed\")\n        }\n        \n        // When - Analyze request with high failure rate context\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        let credentialStuffingEvent = events.first { $0.threat == .credentialStuffing }\n        XCTAssertNotNil(credentialStuffingEvent)\n        XCTAssertEqual(credentialStuffingEvent?.severity, .medium)\n    }\n    \n    // MARK: - Payload Size Analysis Tests\n    \n    func testLargePayloadDetection() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/upload\")!)\n        let largePayload = Data(repeating: 0xFF, count: 2 * 1024 * 1024) // 2MB\n        let source = \"203.0.113.5\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: largePayload)\n        \n        // Then\n        let ddosEvent = events.first { $0.threat == .ddosAttack }\n        XCTAssertNotNil(ddosEvent)\n        XCTAssertEqual(ddosEvent?.severity, .medium)\n    }\n    \n    // MARK: - Blacklist Management Tests\n    \n    func testManualBlacklisting() {\n        // Given\n        let source = \"198.51.100.5\"\n        \n        // When\n        securityMonitor.blockSource(source, reason: \"Manual block for testing\")\n        \n        // Then\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n        \n        let events = securityMonitor.getRecentEvents()\n        let blockEvent = events.first { $0.source == source && $0.threat == .unauthorizedAccess }\n        XCTAssertNotNil(blockEvent)\n        XCTAssertTrue(blockEvent?.blocked ?? false)\n    }\n    \n    func testBlacklistRemoval() {\n        // Given\n        let source = \"192.0.2.5\"\n        securityMonitor.blockSource(source)\n        XCTAssertTrue(securityMonitor.shouldBlockSource(source))\n        \n        // When\n        securityMonitor.unblockSource(source)\n        \n        // Then\n        XCTAssertFalse(securityMonitor.shouldBlockSource(source))\n    }\n    \n    func testBlockedSourceAccessAttempt() {\n        // Given\n        let source = \"203.0.113.6\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        securityMonitor.blockSource(source)\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        \n        // Then\n        XCTAssertFalse(events.isEmpty)\n        let unauthorizedEvent = events.first { $0.threat == .unauthorizedAccess }\n        XCTAssertNotNil(unauthorizedEvent)\n        XCTAssertEqual(unauthorizedEvent?.severity, .high)\n        XCTAssertTrue(unauthorizedEvent?.blocked ?? false)\n    }\n    \n    // MARK: - Security Metrics Tests\n    \n    func testSecurityMetricsCalculation() {\n        // Given\n        let sources = [\"192.0.2.10\", \"192.0.2.11\", \"192.0.2.12\"]\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When - Generate various security events\n        // XSS Attack\n        let xssURL = URL(string: \"https://api.example.com/search?q=<script>alert('xss')</script>\")!\n        let xssRequest = URLRequest(url: xssURL)\n        _ = securityMonitor.analyzeRequest(xssRequest, source: sources[0])\n        \n        // SQL Injection\n        let sqlURL = URL(string: \"https://api.example.com/user?id=1' OR '1'='1\")!\n        let sqlRequest = URLRequest(url: sqlURL)\n        _ = securityMonitor.analyzeRequest(sqlRequest, source: sources[1])\n        \n        // DDoS Simulation\n        for _ in 1...12 {\n            _ = securityMonitor.analyzeRequest(request, source: sources[2])\n        }\n        \n        let metrics = securityMonitor.getSecurityMetrics()\n        \n        // Then\n        XCTAssertGreaterThan(metrics.totalThreats, 0)\n        XCTAssertGreaterThan(metrics.threatsBlocked, 0)\n        XCTAssertGreaterThan(metrics.criticalThreats, 0)\n        XCTAssertTrue(metrics.topThreatTypes.count > 0)\n        XCTAssertTrue(metrics.topSources.count > 0)\n        XCTAssertNotEqual(metrics.systemHealth, .healthy) // Should be degraded due to attacks\n    }\n    \n    func testSystemHealthAssessment() {\n        // Given\n        let source = \"203.0.113.7\"\n        \n        // When - Generate critical threats\n        let criticalPayload = \"'; DROP DATABASE important; --\".data(using: .utf8)!\n        let criticalRequest = URLRequest(url: URL(string: \"https://api.example.com/data\")!)\n        \n        for _ in 1...15 { // Generate many critical events\n            _ = securityMonitor.analyzeRequest(criticalRequest, source: source + \"\\($0)\", payload: criticalPayload)\n        }\n        \n        let metrics = securityMonitor.getSecurityMetrics()\n        \n        // Then\n        XCTAssertEqual(metrics.systemHealth, .underAttack)\n        XCTAssertGreaterThan(metrics.criticalThreats, 10)\n    }\n    \n    func testThreatLevelAssessment() {\n        // Given - Generate some threats\n        let source = \"198.51.100.7\"\n        let maliciousPayload = \"<script>alert('test')</script>\".data(using: .utf8)!\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When\n        _ = securityMonitor.analyzeRequest(request, source: source, payload: maliciousPayload)\n        let threatLevel = securityMonitor.getThreatLevel()\n        \n        // Then\n        XCTAssertGreaterThanOrEqual(threatLevel.rawValue, SecurityEvent.SecuritySeverity.medium.rawValue)\n    }\n    \n    // MARK: - Event Export and History Tests\n    \n    func testEventExport() {\n        // Given\n        let source = \"192.0.2.8\"\n        let maliciousURL = URL(string: \"https://api.example.com/test?q=<script>alert(1)</script>\")!\n        let request = URLRequest(url: maliciousURL)\n        \n        let startTime = Date()\n        _ = securityMonitor.analyzeRequest(request, source: source)\n        \n        // When\n        let exportedEvents = securityMonitor.exportEvents(since: startTime)\n        \n        // Then\n        XCTAssertFalse(exportedEvents.isEmpty)\n        let xssEvent = exportedEvents.first { $0.threat == .xssAttack }\n        XCTAssertNotNil(xssEvent)\n        XCTAssertEqual(xssEvent?.source, source)\n    }\n    \n    func testRecentEventsRetrieval() {\n        // Given\n        let sources = [\"203.0.113.8\", \"198.51.100.8\", \"192.0.2.9\"]\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When - Generate events from different sources\n        for source in sources {\n            securityMonitor.blockSource(source, reason: \"Test block\")\n        }\n        \n        let recentEvents = securityMonitor.getRecentEvents(limit: 5)\n        \n        // Then\n        XCTAssertLessThanOrEqual(recentEvents.count, 5)\n        XCTAssertGreaterThan(recentEvents.count, 0)\n    }\n    \n    // MARK: - Configuration Management Tests\n    \n    func testConfigurationUpdate() {\n        // Given\n        let strictConfig = AnomalyConfig(\n            requestThreshold: 3,\n            timeWindow: 60.0,\n            failureRateThreshold: 0.1,\n            patternDetectionEnabled: true,\n            mlDetectionEnabled: false,\n            geoLocationChecks: false\n        )\n        \n        let source = \"203.0.113.9\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When\n        securityMonitor.updateConfig(strictConfig)\n        \n        // Make requests to trigger threshold\n        var detectedThreat = false\n        for _ in 1...5 {\n            let events = securityMonitor.analyzeRequest(request, source: source)\n            if events.contains(where: { $0.threat == .ddosAttack }) {\n                detectedThreat = true\n                break\n            }\n        }\n        \n        // Then\n        XCTAssertTrue(detectedThreat, \"Should detect threat with lower threshold\")\n    }\n    \n    // MARK: - Reporting and Analytics Tests\n    \n    func testTopAttackersIdentification() {\n        // Given\n        let attackingSources = [\"203.0.113.10\": 5, \"198.51.100.10\": 3, \"192.0.2.10\": 7]\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        // When - Generate attacks from different sources\n        for (source, attackCount) in attackingSources {\n            for _ in 1...attackCount {\n                _ = securityMonitor.analyzeRequest(request, source: source)\n            }\n        }\n        \n        let topAttackers = securityMonitor.getTopAttackers(limit: 3)\n        \n        // Then\n        XCTAssertLessThanOrEqual(topAttackers.count, 3)\n        XCTAssertGreaterThan(topAttackers.count, 0)\n        \n        // Should be sorted by attack count\n        if topAttackers.count >= 2 {\n            XCTAssertGreaterThanOrEqual(topAttackers[0].1, topAttackers[1].1)\n        }\n    }\n    \n    func testSecurityReportGeneration() {\n        // Given\n        let source = \"198.51.100.11\"\n        let maliciousURL = URL(string: \"https://api.example.com/test?q=' OR 1=1 --\")!\n        let request = URLRequest(url: maliciousURL)\n        \n        // When\n        _ = securityMonitor.analyzeRequest(request, source: source)\n        let report = securityMonitor.generateSecurityReport(period: 3600)\n        \n        // Then\n        XCTAssertTrue(report.contains(\"Security Report\"))\n        XCTAssertTrue(report.contains(\"Summary:\"))\n        XCTAssertTrue(report.contains(\"Total Threats:\"))\n        XCTAssertTrue(report.contains(\"Top Threat Types:\"))\n        XCTAssertTrue(report.contains(\"Top Sources:\"))\n    }\n    \n    // MARK: - Edge Cases and Error Handling Tests\n    \n    func testInvalidURLHandling() {\n        // Given\n        let request = URLRequest(url: URL(string: \"invalid-url\")!)\n        let source = \"192.0.2.11\"\n        \n        // When & Then - Should not crash\n        let events = securityMonitor.analyzeRequest(request, source: source)\n        // May or may not generate events, but should not crash\n    }\n    \n    func testEmptyPayloadHandling() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        let emptyPayload = Data()\n        let source = \"203.0.113.11\"\n        \n        // When\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: emptyPayload)\n        \n        // Then - Should handle gracefully\n        // Empty payload should not trigger payload-based threats\n        let payloadThreats = events.filter {\n            $0.threat == .maliciousPayload || $0.threat == .sqlInjection || $0.threat == .xssAttack\n        }\n        XCTAssertTrue(payloadThreats.isEmpty)\n    }\n    \n    func testNonUTF8PayloadHandling() {\n        // Given\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        let binaryPayload = Data([0xFF, 0xFE, 0x00, 0x01, 0x80, 0x90]) // Invalid UTF-8\n        let source = \"198.51.100.12\"\n        \n        // When & Then - Should not crash\n        let events = securityMonitor.analyzeRequest(request, source: source, payload: binaryPayload)\n        // Should handle non-UTF8 data gracefully\n    }\n    \n    func testConcurrentThreatAnalysis() {\n        // Given\n        let sources = (1...20).map { \"192.0.2.\\($0)\" }\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        let expectation = expectation(description: \"Concurrent threat analysis\")\n        expectation.expectedFulfillmentCount = sources.count\n        \n        let queue = DispatchQueue(label: \"threat-analysis\", attributes: .concurrent)\n        \n        // When - Analyze threats concurrently\n        for source in sources {\n            queue.async {\n                let events = self.securityMonitor.analyzeRequest(request, source: source)\n                // Should handle concurrent access safely\n                expectation.fulfill()\n            }\n        }\n        \n        // Then\n        waitForExpectations(timeout: 5.0)\n        \n        let metrics = securityMonitor.getSecurityMetrics()\n        XCTAssertGreaterThan(metrics.totalThreats, 0)\n    }\n    \n    // MARK: - Performance Tests\n    \n    func testThreatAnalysisPerformance() {\n        // Given\n        let requests = (1...100).map { i in\n            URLRequest(url: URL(string: \"https://api.example.com/test\\(i)\")!)\n        }\n        let source = \"performance.test.com\"\n        \n        // When & Then\n        measure {\n            for request in requests {\n                _ = securityMonitor.analyzeRequest(request, source: source)\n            }\n        }\n    }\n    \n    func testSecurityMetricsPerformance() {\n        // Given - Generate some events first\n        let source = \"metrics.performance.test\"\n        let request = URLRequest(url: URL(string: \"https://api.example.com/test\")!)\n        \n        for _ in 1...50 {\n            _ = securityMonitor.analyzeRequest(request, source: source)\n        }\n        \n        // When & Then\n        measure {\n            _ = securityMonitor.getSecurityMetrics()\n        }\n    }\n    \n    // MARK: - Real-time Monitoring Tests\n    \n    func testRealTimeEventUpdates() {\n        // Given\n        let expectation = expectation(description: \"Real-time event updates\")\n        var receivedEvents: [SecurityEvent] = []\n        \n        securityMonitor.$recentEvents\n            .sink { events in\n                receivedEvents = events\n                if !events.isEmpty {\n                    expectation.fulfill()\n                }\n            }\n            .store(in: &cancellables)\n        \n        // When\n        let maliciousURL = URL(string: \"https://api.example.com/test?q=<script>alert('realtime')</script>\")!\n        let request = URLRequest(url: maliciousURL)\n        _ = securityMonitor.analyzeRequest(request, source: \"realtime.test\")\n        \n        // Then\n        waitForExpectations(timeout: 2.0)\n        XCTAssertFalse(receivedEvents.isEmpty)\n    }\n    \n    func testActiveThreatTracking() {\n        // Given\n        let expectation = expectation(description: \"Active threat tracking\")\n        var activeThreatCounts: [SecurityThreat: Int] = [:]\n        \n        securityMonitor.$activeThreats\n            .sink { threats in\n                activeThreatCounts = threats\n                if !threats.isEmpty {\n                    expectation.fulfill()\n                }\n            }\n            .store(in: &cancellables)\n        \n        // When\n        let xssURL = URL(string: \"https://api.example.com/test?q=<script>alert('active')</script>\")!\n        let xssRequest = URLRequest(url: xssURL)\n        _ = securityMonitor.analyzeRequest(xssRequest, source: \"active.threat.test\")\n        \n        // Then\n        waitForExpectations(timeout: 2.0)\n        XCTAssertGreaterThan(activeThreatCounts[.xssAttack] ?? 0, 0)\n    }\n}\n"